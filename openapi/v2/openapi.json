{
  "swagger": "2.0",
  "info": {
    "title": "Fulfillment API",
    "version": "0.0.1",
    "contact": {
      "name": "Innabox project",
      "url": "https://github.com/innabox"
    },
    "license": {
      "name": "Apache-2.0",
      "url": "https://github.com/innabox/fulfillment-api/blob/main/LICENSE"
    }
  },
  "tags": [
    {
      "name": "Events"
    },
    {
      "name": "ClusterTemplates"
    },
    {
      "name": "Clusters"
    },
    {
      "name": "ComputeInstanceTemplates"
    },
    {
      "name": "ComputeInstances"
    },
    {
      "name": "HostClasses"
    },
    {
      "name": "HostPools"
    },
    {
      "name": "Hosts"
    },
    {
      "name": "NetworkClasses"
    },
    {
      "name": "SecurityGroups"
    },
    {
      "name": "Subnets"
    },
    {
      "name": "VirtualNetworks"
    },
    {
      "name": "Metadata"
    }
  ],
  "schemes": [
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/events/v1/events": {
      "get": {
        "summary": "Start watching events.",
        "description": "Note that the server doesn't make any guarantee about the delivery or order of these events. In particular events\nthat happen while the client is disconnected will not be delivered. Clients should consider using other mechanisms\nto ensure that they process objects correctly. For example, they can combine this watch mechanism with periodic\nredconciliation of all the objects.",
        "operationId": "Events_Watch",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1EventsWatchResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "v1EventsWatchResponseStreamResult"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe value of this parameter is a [CEL](https://cel.dev) boolean expression. The `event` variable will contain the\nfields of the event. If the result of the expression is `true` then the event will be sent by the server. For\nexample, to receive only the events that indicate that a cluster order has been modified and is now in the\nfulfilled state:\n\n```\nevent.type == EVENT_TYPE_OBJECT_CREATED \u0026\u0026 event.cluster_order.status.state == CLUSTER_ORDER_STATE_FULFILLED\n```\n\nIf this isn't provided, or if the value is empty, then all the events that the user has permission to see will be\nsent by the server.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Events"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_templates": {
      "get": {
        "summary": "Retrieves the list of cluster templates.",
        "operationId": "ClusterTemplates_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplatesListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the template instead of the names of the columns of a table. For example, in order to retrieve\nall the templates with a title starting with `large` the value should be:\n\n    title like 'large%'\n\nIf this isn't provided, or if the value is empty, then all the templates that the user has permission to see will\nbe returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the templated instead of the names of the columns of a table. For example, in order to\nsort the templates descending by title the value should be:\n\n    name desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      },
      "post": {
        "summary": "Creates a new cluster template.",
        "operationId": "ClusterTemplates_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplate"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplate"
            }
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_templates/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific cluster template.",
        "operationId": "ClusterTemplates_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplate"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      },
      "delete": {
        "summary": "Delete a cluster template.",
        "operationId": "ClusterTemplates_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplatesDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/cluster_templates/{object.id}": {
      "patch": {
        "summary": "Updates an existint cluster template.",
        "operationId": "ClusterTemplates_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ClusterTemplate"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the template.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata"
                },
                "title": {
                  "type": "string",
                  "description": "Human friendly short description of the template, only a few words, suitable for displaying in one single line on a\nUI or CLI."
                },
                "description": {
                  "type": "string",
                  "description": "Human friendly long description of the template, using Markdown format."
                },
                "parameters": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "$ref": "#/definitions/v1ClusterTemplateParameterDefinition"
                  },
                  "description": "Definitions of the parameters that can be used to customize the template.\n\nNote that these are only the *definitions* of the parameters, not the actual values. The actual values are in the\n`spec.template_parameters` field of the cluster."
                },
                "node_sets": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/definitions/v1ClusterTemplateNodeSet"
                  },
                  "description": "Initial node sets of the cluster."
                }
              },
              "description": "A cluster template defines a type of cluster that can be created by the user. Note that the user doesn't create these\ntemplates: the system provides a collection of them, and the user chooses one."
            }
          }
        ],
        "tags": [
          "ClusterTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/clusters": {
      "get": {
        "summary": "Retrieves the list of clusters.",
        "operationId": "Clusters_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClustersListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the cluster instead of the names of the columns of a table. For example, in order to retrieve\nall the cluster with a API URL starting with `http:` the value should be:\n\n    api_url like 'http:%'\n\nIf this isn't provided, or if the value is empty, then all the clusters that the user has permission to see will be\nreturned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the cluster instead of the names of the columns of a table. For example, in order to\nsort the clusters descending by API URL the value should be:\n\n    api_url desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      },
      "post": {
        "summary": "Creates a new cluster.",
        "description": "Note that this operation is not allowed for regular users, only for the server. Regular users create clusters\nindirectly, creating a cluster order that will eventually result in the system creating a cluster.",
        "operationId": "Clusters_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1Cluster"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1Cluster"
            }
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/clusters/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific cluster.",
        "operationId": "Clusters_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1Cluster"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      },
      "delete": {
        "summary": "Delete a cluster.",
        "operationId": "Clusters_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ClustersDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/clusters/{id}/kubeconfig": {
      "get": {
        "summary": "Returns the admin Kubeconfig of the cluster.",
        "description": "This is intended for use with HTTP and returns the YAML text of the Kubeconfig directly using the content type\n`application/yaml`.\n\nbuf:lint:ignore RPC_RESPONSE_STANDARD_NAME\nbuf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE",
        "operationId": "Clusters_GetKubeconfigViaHttp",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiHttpBody"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/clusters/{id}/password": {
      "get": {
        "summary": "Returns the admin password of the cluster.",
        "description": "This is intended for use with HTTP and returns the YAML text of the password directly using the content type\n`text/plain`.\n\nbuf:lint:ignore RPC_RESPONSE_STANDARD_NAME\nbuf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE",
        "operationId": "Clusters_GetPasswordViaHttp",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/apiHttpBody"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/clusters/{object.id}": {
      "patch": {
        "summary": "Updates an existing cluster.",
        "description": "In the HTTP+JSON version of the API this is mapped to the `PATCH` verb and the `update_mask` field is automatically\npopulated from the list of fields present in the request body. For example, to update the `state` of a cluster to\n`READY` the request line should be like this:\n\n```http\nPATCH /api/fulfillment/v1/clusters/123\n```\n\nAnd the request body should be like this:\n\n```json\n{\n  \"status\": {\n    \"state\": \"CLUSTER_STATE_READY\"\n  }\n}\n```\n\nThe response body will contain the modified object.",
        "operationId": "Clusters_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1Cluster"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the cluster.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata"
                },
                "spec": {
                  "$ref": "#/definitions/v1ClusterSpec"
                },
                "status": {
                  "$ref": "#/definitions/v1ClusterStatus"
                }
              },
              "description": "Contains the details of the cluster.\n\nThe `spec` contains the desired details, and may be modified by the user. The `status` contains the current status of\nthe cluster, is provided by the system and can't be modified by the user."
            }
          }
        ],
        "tags": [
          "Clusters"
        ]
      }
    },
    "/api/fulfillment/v1/compute_instance_templates": {
      "get": {
        "summary": "Retrieves the list of compute instance templates.",
        "operationId": "ComputeInstanceTemplates_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ComputeInstanceTemplatesListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the template instead of the names of the columns of a table. For example, in order to retrieve\nall the templates with a title starting with `large` the value should be:\n\n    title like 'large%'\n\nIf this isn't provided, or if the value is empty, then all the templates that the user has permission to see will\nbe returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the templated instead of the names of the columns of a table. For example, in order to\nsort the templates descending by title the value should be:\n\n    name desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "ComputeInstanceTemplates"
        ]
      },
      "post": {
        "summary": "Creates a new compute instance template.",
        "operationId": "ComputeInstanceTemplates_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ComputeInstanceTemplate"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1ComputeInstanceTemplate"
            }
          }
        ],
        "tags": [
          "ComputeInstanceTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/compute_instance_templates/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific compute instance template.",
        "operationId": "ComputeInstanceTemplates_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ComputeInstanceTemplate"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ComputeInstanceTemplates"
        ]
      },
      "delete": {
        "summary": "Delete a compute instance template.",
        "operationId": "ComputeInstanceTemplates_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ComputeInstanceTemplatesDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ComputeInstanceTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/compute_instance_templates/{object.id}": {
      "patch": {
        "summary": "Updates an existing compute instance template.",
        "operationId": "ComputeInstanceTemplates_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ComputeInstanceTemplate"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the template.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata"
                },
                "title": {
                  "type": "string",
                  "description": "Human friendly short description of the template, only a few words, suitable for displaying in one single line on a\nUI or CLI."
                },
                "description": {
                  "type": "string",
                  "description": "Human friendly long description of the template, using Markdown format."
                },
                "parameters": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "$ref": "#/definitions/v1ComputeInstanceTemplateParameterDefinition"
                  },
                  "description": "Definitions of the parameters that can be used to customize the template.\n\nNote that these are only the *definitions* of the parameters, not the actual values. The actual values are in the\n`spec.template_parameters` field of the compute instance."
                }
              },
              "description": "A compute instance template defines a type of compute instance that can be created by the user. Note that the user doesn't create these\ntemplates: the system provides a collection of them, and the user chooses one."
            }
          }
        ],
        "tags": [
          "ComputeInstanceTemplates"
        ]
      }
    },
    "/api/fulfillment/v1/compute_instances": {
      "get": {
        "summary": "Retrieves the list of compute instances.",
        "operationId": "ComputeInstances_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ComputeInstancesListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the compute instance instead of the names of the columns of a table. For example, in order to retrieve\nall the compute instances with an IP address starting with `192.168` the value should be:\n\n    ip_address like '192.168%'\n\nIf this isn't provided, or if the value is empty, then all the compute instances that the user has permission to see will be\nreturned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the compute instance instead of the names of the columns of a table. For example, in order to\nsort the compute instances descending by IP address the value should be:\n\n    ip_address desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "ComputeInstances"
        ]
      },
      "post": {
        "summary": "Creates a new compute instance.",
        "description": "Note that this operation is not allowed for regular users, only for the server. Regular users create compute instances\nindirectly, creating a compute instance order that will eventually result in the system creating a compute instance.",
        "operationId": "ComputeInstances_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ComputeInstance"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1ComputeInstance"
            }
          }
        ],
        "tags": [
          "ComputeInstances"
        ]
      }
    },
    "/api/fulfillment/v1/compute_instances/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific compute instance.",
        "operationId": "ComputeInstances_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ComputeInstance"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ComputeInstances"
        ]
      },
      "delete": {
        "summary": "Delete a compute instance.",
        "operationId": "ComputeInstances_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ComputeInstancesDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "ComputeInstances"
        ]
      }
    },
    "/api/fulfillment/v1/compute_instances/{object.id}": {
      "patch": {
        "summary": "Updates an existing compute instance.",
        "description": "In the HTTP+JSON version of the API this is mapped to the `PATCH` verb and the `update_mask` field is automatically\npopulated from the list of fields present in the request body. For example, to update the `state` of a compute instance to\n`READY` the request line should be like this:\n\n```http\nPATCH /api/fulfillment/v1/compute_instances/123\n```\n\nAnd the request body should be like this:\n\n```json\n{\n  \"status\": {\n    \"state\": \"COMPUTE_INSTANCE_STATE_READY\"\n  }\n}\n```\n\nThe response body will contain the modified object.",
        "operationId": "ComputeInstances_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1ComputeInstance"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the compute instance.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata"
                },
                "spec": {
                  "$ref": "#/definitions/v1ComputeInstanceSpec"
                },
                "status": {
                  "$ref": "#/definitions/v1ComputeInstanceStatus"
                }
              },
              "description": "Contains the details of the compute instance.\n\nThe `spec` contains the desired details, and may be modified by the user. The `status` contains the current status of\nthe compute instance, is provided by the system and can't be modified by the user."
            }
          }
        ],
        "tags": [
          "ComputeInstances"
        ]
      }
    },
    "/api/fulfillment/v1/host_classes": {
      "get": {
        "summary": "Retrieves the list of host classes.",
        "operationId": "HostClasses_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1HostClassesListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the host class instead of the names of the columns of a table. For example, in order to\nretrieve all the host classes with a title starting with `gpu` the value should be:\n\n    title like 'gpu%'\n\nIf this isn't provided, or if the value is empty, then all the host classes that the user has permission to see\nwill be returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the host class instead of the names of the columns of a table. For example, in order to\nsort the templates descending by title the value should be:\n\n    name desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "HostClasses"
        ]
      },
      "post": {
        "summary": "Creates a new host class.",
        "description": "This method isn't allowed for regular users, only for the system itself.",
        "operationId": "HostClasses_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1HostClass"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1HostClass"
            }
          }
        ],
        "tags": [
          "HostClasses"
        ]
      }
    },
    "/api/fulfillment/v1/host_classes/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific host classes.",
        "operationId": "HostClasses_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1HostClass"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "HostClasses"
        ]
      },
      "delete": {
        "summary": "Delete a host class.",
        "description": "This method isn't allowed for regular users, only for the system itself.",
        "operationId": "HostClasses_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1HostClassesDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "HostClasses"
        ]
      }
    },
    "/api/fulfillment/v1/host_classes/{object.id}": {
      "patch": {
        "summary": "Updates an existint host class.",
        "description": "This method isn't allowed for regular users, only for the system itself.",
        "operationId": "HostClasses_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1HostClass"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the class.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata",
                  "description": "Metadata of the host class."
                },
                "title": {
                  "type": "string",
                  "description": "Human friendly short description of the host class, only a few words, suitable for displaying in one single\nline on a UI or CLI."
                },
                "description": {
                  "type": "string",
                  "description": "Human friendly long description of the host class, using Markdown format."
                }
              },
              "description": "Describes a set of hosts that share characteristics.\n\nFor example there could be a host class `acme_1tb` to describe the set of hosts manifactured by ACME and with 1 TiB\nof RAM, and another `ibm_mi300x` to describe the set of hosts manufactured IBM and with a MI300X GPU.\n\nThis is similar to the _instance type_ concept used by many cloud providers.\n\nThe detailed chracteristics of the host (CPU, memory, GPU, etc) will be in the `description` field."
            }
          }
        ],
        "tags": [
          "HostClasses"
        ]
      }
    },
    "/api/fulfillment/v1/host_pools": {
      "get": {
        "summary": "Retrieves the list of host pools.",
        "operationId": "HostPools_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1HostPoolsListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the host pool instead of the names of the columns of a table. For example, in order to retrieve\nall the host pool with a API URL starting with `http:` the value should be:\n\n    api_url like 'http:%'\n\nIf this isn't provided, or if the value is empty, then all the host pools that the user has permission to see will be\nreturned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the host pool instead of the names of the columns of a table. For example, in order to\nsort the host pools descending by API URL the value should be:\n\n    api_url desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "HostPools"
        ]
      },
      "post": {
        "summary": "Creates a new host pool.",
        "operationId": "HostPools_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1HostPool"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1HostPool"
            }
          }
        ],
        "tags": [
          "HostPools"
        ]
      }
    },
    "/api/fulfillment/v1/host_pools/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific host pool.",
        "operationId": "HostPools_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1HostPool"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "HostPools"
        ]
      },
      "delete": {
        "summary": "Delete a host pool.",
        "operationId": "HostPools_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1HostPoolsDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "HostPools"
        ]
      }
    },
    "/api/fulfillment/v1/host_pools/{object.id}": {
      "patch": {
        "summary": "Updates an existing host pool.",
        "description": "In the HTTP+JSON version of the API this is mapped to the `PATCH` verb and the `update_mask` field is automatically\npopulated from the list of fields present in the request body. For example, to update the `state` of a host pool to\n`READY` the request line should be like this:\n\n```http\nPATCH /api/fulfillment/v1/host_pools/123\n```\n\nAnd the request body should be like this:\n\n```json\n{\n  \"spec\": {\n    \"host_sets\": [{ \"host_class\": \"fc430\", \"size\": 3 }]\n  }\n}\n```\n\nThe response body will contain the modified object.",
        "operationId": "HostPools_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1HostPool"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the host pool.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata"
                },
                "spec": {
                  "$ref": "#/definitions/v1HostPoolSpec"
                },
                "status": {
                  "$ref": "#/definitions/v1HostPoolStatus"
                }
              },
              "description": "Contains the details of the host pool.\n\nThe `spec` contains the desired details, and may be modified by the user. The `status` contains the current status of\nthe host pool, is provided by the system and can't be modified by the user."
            }
          }
        ],
        "tags": [
          "HostPools"
        ]
      }
    },
    "/api/fulfillment/v1/hosts": {
      "get": {
        "summary": "Retrieves the list of hosts.",
        "operationId": "Hosts_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1HostsListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the network instead of the names of the columns of a table. For example, in order to retrieve\nall the hosts with a title starting with `foo` the value should be:\n\n    title like 'foo%'\n\nIf this isn't provided, or if the value is empty, then all the hosts that the user has permission to see will be\nreturned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the network instead of the names of the columns of a table. For example, in order to\nsort the hosts descending by title the value should be:\n\n    title desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Hosts"
        ]
      },
      "post": {
        "summary": "Creates a new host.",
        "operationId": "Hosts_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1Host"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1Host"
            }
          }
        ],
        "tags": [
          "Hosts"
        ]
      }
    },
    "/api/fulfillment/v1/hosts/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific host.",
        "operationId": "Hosts_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1Host"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Hosts"
        ]
      },
      "delete": {
        "summary": "Delete a host.",
        "operationId": "Hosts_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1HostsDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Hosts"
        ]
      }
    },
    "/api/fulfillment/v1/hosts/{object.id}": {
      "patch": {
        "summary": "Updates an existing host.",
        "description": "In the HTTP+JSON version of the API this is mapped to the `PATCH` verb and the `update_mask` field is automatically\npopulated from the list of fields present in the request body. For example, to update the `title` of a host to\n`foo` the request line should be like this:\n\n```http\nPATCH /api/fulfillment/v1/hosts/123\n```\n\nAnd the request body should be like this:\n\n```json\n{\n  \"title\": \"foo\"\n}\n```\n\nThe response body will contain the modified object.",
        "operationId": "Hosts_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1Host"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the host.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata"
                },
                "spec": {
                  "$ref": "#/definitions/v1HostSpec"
                },
                "status": {
                  "$ref": "#/definitions/v1HostStatus"
                }
              },
              "description": "Contains the details of the host.\n\nThe `spec` contains the desired details, and may be modified by the user. The `status` contains the current status of\nthe host, is provided by the system and can't be modified by the user."
            }
          }
        ],
        "tags": [
          "Hosts"
        ]
      }
    },
    "/api/fulfillment/v1/network_classes": {
      "get": {
        "summary": "Retrieves the list of network classes.",
        "operationId": "NetworkClasses_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1NetworkClassesListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the network class instead of the names of the columns of a table. For example, in order to\nretrieve all the network classes with an implementation_strategy of `udn-net` the value should be:\n\n    implementation_strategy = 'udn-net'\n\nOr to retrieve network classes with titles starting with `physical`:\n\n    title like 'physical%'\n\nIf this isn't provided, or if the value is empty, then all the network classes that the user has permission to see\nwill be returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the network class instead of the names of the columns of a table. For example, in order to\nsort the network classes descending by title the value should be:\n\n    title desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "NetworkClasses"
        ]
      },
      "post": {
        "summary": "Creates a new network class.",
        "description": "This method isn't allowed for regular users, only for the system itself.",
        "operationId": "NetworkClasses_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1NetworkClass"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1NetworkClass"
            }
          }
        ],
        "tags": [
          "NetworkClasses"
        ]
      }
    },
    "/api/fulfillment/v1/network_classes/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific network class.",
        "operationId": "NetworkClasses_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1NetworkClass"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "NetworkClasses"
        ]
      },
      "delete": {
        "summary": "Deletes a network class.",
        "description": "This method isn't allowed for regular users, only for the system itself.",
        "operationId": "NetworkClasses_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1NetworkClassesDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "NetworkClasses"
        ]
      }
    },
    "/api/fulfillment/v1/network_classes/{object.id}": {
      "patch": {
        "summary": "Updates an existing network class.",
        "description": "This method isn't allowed for regular users, only for the system itself.",
        "operationId": "NetworkClasses_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1NetworkClass"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the network class.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata",
                  "description": "Metadata of the network class."
                },
                "title": {
                  "type": "string",
                  "description": "Human friendly short description of the network class, only a few words, suitable for displaying in one single\nline on a UI or CLI. For example: \"UDN Network\" or \"Physical Network\"."
                },
                "description": {
                  "type": "string",
                  "description": "Human friendly long description of the network class, using Markdown format. This should explain the\ncharacteristics of networks created using this class, including performance characteristics, isolation\nguarantees, and any limitations or requirements."
                },
                "implementation_strategy": {
                  "type": "string",
                  "description": "Implementation strategy identifier for this network class. This is the discriminator that VirtualNetwork\nresources use to select which network backend to use. For example: \"udn-net\", \"phys-net\", \"ovn-kubernetes\".\n\nThis value is system-defined and immutable once the NetworkClass is created."
                },
                "constraints": {
                  "$ref": "#/definitions/v1NetworkClassConstraints",
                  "description": "Class-specific configuration constraints and options. These define implementation-specific parameters that\nnetworks using this class must or may configure."
                },
                "capabilities": {
                  "$ref": "#/definitions/v1NetworkClassCapabilities",
                  "description": "Capabilities that this network class supports. These describe what features are available when using this\nnetwork implementation strategy."
                },
                "status": {
                  "$ref": "#/definitions/v1NetworkClassStatus",
                  "description": "Current operational status of the network class."
                }
              },
              "description": "Describes a network implementation strategy available for creating virtual networks.\n\nNetworkClass represents a specific network backend implementation that VirtualNetworks can use. For example,\nthere could be a network class `udn-net` to describe networks implemented using User-Defined Networks in\nKubernetes, and another `phys-net` for networks backed by physical network infrastructure.\n\nThis is similar to the _storage class_ concept used by Kubernetes for persistent volumes, or the _instance type_\nconcept used by cloud providers for compute resources.\n\nUsers query available NetworkClasses to discover which network implementation strategies they can choose when\ncreating VirtualNetworks. The `implementation_strategy` field is the key identifier that VirtualNetwork resources\nreference to select their network backend."
            }
          }
        ],
        "tags": [
          "NetworkClasses"
        ]
      }
    },
    "/api/fulfillment/v1/security_groups": {
      "get": {
        "summary": "Retrieves the list of security groups.",
        "operationId": "SecurityGroups_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SecurityGroupsListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the security group instead of the names of the columns of a table. For example, in order to\nretrieve all the security groups with a virtual_network of `vnet-123` the value should be:\n\n    virtual_network = 'vnet-123'\n\nOr to retrieve security groups with names starting with `web-servers`:\n\n    metadata.name like 'web-servers%'\n\nIf this isn't provided, or if the value is empty, then all the security groups that the user has permission to see\nwill be returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the security group instead of the names of the columns of a table. For example, in order to\nsort the security groups descending by creation time the value should be:\n\n    metadata.created_at desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "SecurityGroups"
        ]
      },
      "post": {
        "summary": "Creates a new security group.",
        "operationId": "SecurityGroups_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1SecurityGroup"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1SecurityGroup"
            }
          }
        ],
        "tags": [
          "SecurityGroups"
        ]
      }
    },
    "/api/fulfillment/v1/security_groups/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific security group.",
        "operationId": "SecurityGroups_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1SecurityGroup"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "SecurityGroups"
        ]
      },
      "delete": {
        "summary": "Deletes a security group.",
        "operationId": "SecurityGroups_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SecurityGroupsDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "SecurityGroups"
        ]
      }
    },
    "/api/fulfillment/v1/security_groups/{object.id}": {
      "patch": {
        "summary": "Updates an existing security group.",
        "operationId": "SecurityGroups_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1SecurityGroup"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the security group.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata",
                  "description": "Metadata of the security group, including name, labels, tenants, and timestamps.\n\nThe parent VirtualNetwork relationship should be specified via metadata.annotations using the\n'osac.io/owner-reference' key with the VirtualNetwork ID as the value. This establishes resource\nhierarchy for garbage collection."
                },
                "spec": {
                  "$ref": "#/definitions/v1SecurityGroupSpec",
                  "description": "Desired configuration of the security group (user-modifiable)."
                },
                "status": {
                  "$ref": "#/definitions/v1SecurityGroupStatus",
                  "description": "Current state of the security group (system-provided, read-only)."
                }
              },
              "description": "Represents a virtual firewall controlling network traffic for compute instances.\n\nSecurityGroup acts as a stateful firewall that controls inbound (ingress) and outbound (egress) traffic for\ncompute instances within a VirtualNetwork. Rules are stateful, meaning return traffic is automatically allowed\nfor established connections.\n\nSecurityGroups follow a default-deny policy: if no rules match, traffic is blocked. This ensures secure-by-default\nbehavior where only explicitly allowed traffic can pass through.\n\nSecurityGroups are scoped to a VirtualNetwork and can be attached to multiple compute instances within that\nnetwork. They cannot be used across different VirtualNetworks.\n\nThe parent VirtualNetwork relationship is established via metadata.annotations using the 'osac.io/owner-reference'\nkey with the VirtualNetwork ID as the value. This enables proper resource hierarchy for garbage collection - when\na VirtualNetwork is deleted, all associated SecurityGroups are automatically cleaned up.\n\nDesign follows AWS Security Groups and Azure Network Security Groups (NSGs) patterns, adapted for cloud-native\nmulti-tenant environments."
            }
          }
        ],
        "tags": [
          "SecurityGroups"
        ]
      }
    },
    "/api/fulfillment/v1/subnets": {
      "get": {
        "summary": "Retrieves the list of subnets.",
        "operationId": "Subnets_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SubnetsListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the subnet instead of the names of the columns of a table. For example, in order to\nretrieve all the subnets with a specific virtual network the value should be:\n\n    virtual_network = 'vn-123'\n\nOr to retrieve subnets with names starting with `frontend`:\n\n    metadata.name like 'frontend-%'\n\nIf this isn't provided, or if the value is empty, then all the subnets that the user has permission to see\nwill be returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the subnet instead of the names of the columns of a table. For example, in order to\nsort the subnets descending by creation time the value should be:\n\n    metadata.created_at desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Subnets"
        ]
      },
      "post": {
        "summary": "Creates a new subnet.",
        "operationId": "Subnets_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1Subnet"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1Subnet"
            }
          }
        ],
        "tags": [
          "Subnets"
        ]
      }
    },
    "/api/fulfillment/v1/subnets/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific subnet.",
        "operationId": "Subnets_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1Subnet"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Subnets"
        ]
      },
      "delete": {
        "summary": "Deletes a subnet.",
        "operationId": "Subnets_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SubnetsDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "Subnets"
        ]
      }
    },
    "/api/fulfillment/v1/subnets/{object.id}": {
      "patch": {
        "summary": "Updates an existing subnet.",
        "operationId": "Subnets_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1Subnet"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the subnet.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata",
                  "description": "Metadata of the subnet, including name, labels, tenants, and timestamps.\n\nThe parent VirtualNetwork relationship should be specified via metadata.annotations using the\n'osac.io/owner-reference' key with the VirtualNetwork ID as the value. This establishes resource\nhierarchy for garbage collection."
                },
                "spec": {
                  "$ref": "#/definitions/v1SubnetSpec",
                  "description": "Desired configuration of the subnet (user-modifiable)."
                },
                "status": {
                  "$ref": "#/definitions/v1SubnetStatus",
                  "description": "Current state of the subnet (system-provided, read-only)."
                }
              },
              "description": "Represents a subdivision of a VirtualNetwork for organizing compute instances.\n\nSubnets subdivide VirtualNetwork IP address space into smaller, manageable segments. Each Subnet belongs to exactly\none parent VirtualNetwork and must be in the same region. Initially, the system supports a 1:1 mapping between\nVirtualNetwork and Subnet (one subnet per network), but the schema is designed to support multiple subnets per\nVirtualNetwork in the future.\n\nSubnets support flexible IP addressing to match the parent VirtualNetwork's capabilities:\n- IPv4-only: Set ipv4_cidr, leave ipv6_cidr empty\n- IPv6-only: Set ipv6_cidr, leave ipv4_cidr empty\n- Dual-stack: Set both ipv4_cidr and ipv6_cidr\n\nThe parent VirtualNetwork relationship should be specified via metadata.annotations using the 'osac.io/owner-reference'\nkey with the VirtualNetwork ID as the value. This establishes resource hierarchy for garbage collection, ensuring\nthat Subnets are automatically cleaned up when their parent VirtualNetwork is deleted.\n\nCIDR blocks must be non-overlapping within the same VirtualNetwork. Each Subnet's CIDR must be a subset of the\nparent VirtualNetwork's CIDR. Validation is enforced at the service layer."
            }
          }
        ],
        "tags": [
          "Subnets"
        ]
      }
    },
    "/api/fulfillment/v1/virtual_networks": {
      "get": {
        "summary": "Retrieves the list of virtual networks.",
        "operationId": "VirtualNetworks_List",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1VirtualNetworksListResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "offset",
            "description": "Index of the first result. If not specified the default value will be zero.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "limit",
            "description": "Maximum number of results to be returned by the server. When not specified all the results will be returned. Note\nthat there may not be enough results to return, and that the server may decide, for performance reasons, to return\nless results than requested.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "filter",
            "description": "Filter criteria.\n\nThe syntax of this parameter is similar to the syntax of the _where_ clause of a SQL statement, but using the names\nof the attributes of the virtual network instead of the names of the columns of a table. For example, in order to\nretrieve all the virtual networks with a region of `us-east-1` the value should be:\n\n    region = 'us-east-1'\n\nOr to retrieve virtual networks with names starting with `prod`:\n\n    metadata.name like 'prod-%'\n\nIf this isn't provided, or if the value is empty, then all the virtual networks that the user has permission to see\nwill be returned.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "order",
            "description": "Order criteria.\n\nThe syntax of this parameter is similar to the syntax of the _order by_ clause of a SQL statement, but using the\nnames of the attributes of the virtual network instead of the names of the columns of a table. For example, in order to\nsort the virtual networks descending by creation time the value should be:\n\n    metadata.created_at desc\n\nIf the parameter isn't provided, or if the value is empty, then the order of the results is undefined.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "VirtualNetworks"
        ]
      },
      "post": {
        "summary": "Creates a new virtual network.",
        "operationId": "VirtualNetworks_Create",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1VirtualNetwork"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1VirtualNetwork"
            }
          }
        ],
        "tags": [
          "VirtualNetworks"
        ]
      }
    },
    "/api/fulfillment/v1/virtual_networks/{id}": {
      "get": {
        "summary": "Retrieves the details of one specific virtual network.",
        "operationId": "VirtualNetworks_Get",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1VirtualNetwork"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "VirtualNetworks"
        ]
      },
      "delete": {
        "summary": "Deletes a virtual network.",
        "operationId": "VirtualNetworks_Delete",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1VirtualNetworksDeleteResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "VirtualNetworks"
        ]
      }
    },
    "/api/fulfillment/v1/virtual_networks/{object.id}": {
      "patch": {
        "summary": "Updates an existing virtual network.",
        "operationId": "VirtualNetworks_Update",
        "responses": {
          "200": {
            "description": "",
            "schema": {
              "$ref": "#/definitions/v1VirtualNetwork"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "object.id",
            "description": "Unique identifier of the virtual network.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "object",
            "in": "body",
            "required": true,
            "schema": {
              "type": "object",
              "properties": {
                "metadata": {
                  "$ref": "#/definitions/v1Metadata",
                  "description": "Metadata of the virtual network, including name, labels, tenants, and timestamps."
                },
                "spec": {
                  "$ref": "#/definitions/v1VirtualNetworkSpec",
                  "description": "Desired configuration of the virtual network (user-modifiable)."
                },
                "status": {
                  "$ref": "#/definitions/v1VirtualNetworkStatus",
                  "description": "Current state of the virtual network (system-provided, read-only)."
                }
              },
              "description": "Represents a tenant-isolated virtual network.\n\nVirtualNetwork provides network isolation for compute instances within a region. Each VirtualNetwork is backed\nby a specific NetworkClass implementation strategy (e.g., \"udn-net\" for User-Defined Networks, \"phys-net\" for\nphysical network infrastructure).\n\nVirtualNetworks support flexible IP addressing:\n- IPv4-only: Set ipv4_cidr, leave ipv6_cidr empty\n- IPv6-only: Set ipv6_cidr, leave ipv4_cidr empty\n- Dual-stack: Set both ipv4_cidr and ipv6_cidr\n\nThe selected NetworkClass must support the requested IP addressing mode via its capabilities.\n\nTenant isolation is enforced via the standard shared.v1.Metadata tenants field. VirtualNetworks are scoped to\na single region and cannot span multiple regions."
            }
          }
        ],
        "tags": [
          "VirtualNetworks"
        ]
      }
    }
  },
  "definitions": {
    "apiHttpBody": {
      "type": "object",
      "properties": {
        "content_type": {
          "type": "string",
          "description": "The HTTP Content-Type header value specifying the content type of the body."
        },
        "data": {
          "type": "string",
          "format": "byte",
          "description": "The HTTP request/response body as raw binary."
        },
        "extensions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          },
          "description": "Application specific response metadata. Must be set in the first response\nfor streaming APIs."
        }
      },
      "description": "Message that represents an arbitrary HTTP body. It should only be used for\npayload formats that can't be represented as JSON, such as raw binary or\nan HTML page.\n\n\nThis message can be used both in streaming and non-streaming API methods in\nthe request as well as the response.\n\nIt can be used as a top-level request field, which is convenient if one\nwants to extract parameters from either the URL or HTTP template into the\nrequest fields and also want access to the raw HTTP body.\n\nExample:\n\n    message GetResourceRequest {\n      // A unique request id.\n      string request_id = 1;\n\n      // The raw HTTP body is bound to this field.\n      google.api.HttpBody http_body = 2;\n\n    }\n\n    service ResourceService {\n      rpc GetResource(GetResourceRequest)\n        returns (google.api.HttpBody);\n      rpc UpdateResource(google.api.HttpBody)\n        returns (google.protobuf.Empty);\n\n    }\n\nExample with streaming methods:\n\n    service CaldavService {\n      rpc GetCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n      rpc UpdateCalendar(stream google.api.HttpBody)\n        returns (stream google.api.HttpBody);\n\n    }\n\nUse of this type only changes how the request and response bodies are\nhandled, all other features will continue to work unchanged."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1Authn": {
      "type": "object",
      "properties": {
        "trusted_token_issuers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of the OAuth issuers whose access tokens are accepted by the server.\n\nThis means that the client can select one of this and then use the OAuth discovery endpoint to find the details of\nthe OAuth server. For example if the value is `https://my.oauth.com` then the client can obtain the details of the\nauthorizatoin server going to the following URL:\n\n  https://my.oauth.com/.well-known/oauth-authorization-server\n\nThe discovery process is defined in [RFC 8414](https://datatracker.ietf.org/doc/html/rfc8414).\n\nNote that having an access token issued by one of this servers doesn't guarantee that the requests from the user\nwill be accepted: it will still be subject to authorization checks that may grant or deny access."
        }
      },
      "description": "Contains the information that helps client know how authentication is managed by the server."
    },
    "v1Cluster": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the cluster."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata"
        },
        "spec": {
          "$ref": "#/definitions/v1ClusterSpec"
        },
        "status": {
          "$ref": "#/definitions/v1ClusterStatus"
        }
      },
      "description": "Contains the details of the cluster.\n\nThe `spec` contains the desired details, and may be modified by the user. The `status` contains the current status of\nthe cluster, is provided by the system and can't be modified by the user."
    },
    "v1ClusterCondition": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/v1ClusterConditionType",
          "description": "Indicates the type of condition."
        },
        "status": {
          "$ref": "#/definitions/v1ConditionStatus",
          "description": "Indicates the status of the condition."
        },
        "last_transition_time": {
          "type": "string",
          "format": "date-time",
          "description": "This time is the last time that the condition was updated."
        },
        "reason": {
          "type": "string",
          "description": "Contains a the reason of the condition in a format suitable for use by programs.\n\nThe possible values will be documented in the object that contains the condition."
        },
        "message": {
          "type": "string",
          "description": "Contains a text giving more details of the condition.\n\nThis will usually be progress reports, or error messages, and are intended for use by humans, to debug problems."
        }
      },
      "description": "Contains the details of a condition that describes the status of a cluster."
    },
    "v1ClusterConditionType": {
      "type": "string",
      "enum": [
        "CLUSTER_CONDITION_TYPE_UNSPECIFIED",
        "CLUSTER_CONDITION_TYPE_PROGRESSING",
        "CLUSTER_CONDITION_TYPE_READY",
        "CLUSTER_CONDITION_TYPE_FAILED",
        "CLUSTER_CONDITION_TYPE_DEGRADED"
      ],
      "default": "CLUSTER_CONDITION_TYPE_UNSPECIFIED",
      "description": "Types of conditions used to describe the status of cluster.\n\n - CLUSTER_CONDITION_TYPE_UNSPECIFIED: Unspecified indicates that the condition is unknown.\n\nThis will never be appear in the `spec.conditions` field of a cluster.\n - CLUSTER_CONDITION_TYPE_PROGRESSING: Indicates that the cluster isn't completely ready yet.\n\nCurrently there are no `reason` values defined.\n - CLUSTER_CONDITION_TYPE_READY: Indicates that the cluster is ready to use.\n\nCurrently there are no `reason` values defined.\n - CLUSTER_CONDITION_TYPE_FAILED: Indicates that the cluster is unusable.\n\nCurrently there are no `reason` values defined.\n - CLUSTER_CONDITION_TYPE_DEGRADED: Indicates that the cluster is degraded."
    },
    "v1ClusterNodeSet": {
      "type": "object",
      "properties": {
        "host_class": {
          "type": "string",
          "description": "Identifier of the class of hosts that are part of the set.\n\nThe details of the host class can be obtained using the `List` and `Get` method of the `HostClasses` service. For\nexample, to get the details of the `acme_1tb` host class using the HTTP+JSON version of the API:\n\n```http\nGET /api/fulfillment/v1/host_classes/acme_1tb\n```\n\nWhich will return something like this:\n\n```json\n{\n  \"id\": \"acme_1tb\",\n  \"title\": \"ACME server with 1 TiB of RAM and no GPU\",\n  \"description\": \"ACME server model XYZ with 1 TiB of RAM, 2 Xeon 6 CPUS and no GPU.\"\n}\n```\n\nThis will be set by the system when the cluster is initially created, according to the template selected by the\nuser.\n\nThe user will not have permission to change this field."
        },
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Number of nodes of the set."
        }
      },
      "description": "Defines a set of nodes that are part of the cluster, all of them of the same class of host."
    },
    "v1ClusterSpec": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string",
          "description": "Reference to the cluster template.\n\nThis is mandatory, and must be the value of the `id` field of one of the cluster templates.\n\nThis can't be modified after the cluster is created."
        },
        "template_parameters": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/protobufAny"
          },
          "description": "Values of the template parameters.\n\nWhen using the HTTP+JSON version of the API the values must be represented as documented in the (ProtoJSON format\ndocument)[https://protobuf.dev/programming-guides/json]. For example, if the template has a `number_of_gpus`\nparameter of integer type, the complete cluster should be represented like this:\n\n```json\n{\n  \"spec\": {\n    \"template_id\": \"123\",\n    \"template_parameters\": {\n      \"number_of_gpus\": {\n        \"@type\": \"type.googleapis.com/google.protobuf.Int32Value\",\n        \"value\": 3\n      }\n    }\n  }\n}\n```\n\nThe possible values of the `@type` are the same as those used by the `type_url` field of the `Any` type:\n\n| Type                           | Value                                             |\n|--------------------------------|---------------------------------------------------|\n| Boolean                        | `type.googleapis.com/google.protobuf.BoolValue`   |\n| Integer number, 32 bits        | `type.googleapis.com/google.protobuf.Int32Value`  |\n| Integer number, 64 bits        | `type.googleapis.com/google.protobuf.Int64Value`  |\n| Floating point number, 32 bits | `type.googleapis.com/google.protobuf.FloatValue`  |\n| Floating point number, 64 bits | `type.googleapis.com/google.protobuf.DoubleValue` |\n| String                         | `type.googleapis.com/google.protobuf.StringValue` |\n| Timestamp                      | `type.googleapis.com/google.protobuf.Timestamp`   |\n| Duration                       | `type.googleapis.com/google.protobuf.Duration`    |\n| Array of bytes                 | `type.googleapis.com/google.protobuf.BytesValue`  |\n| Any JSON value                 | `type.googleapis.com/google.protobuf.Value`       |\n\nThese parameters can't be modified after the cluster is created."
        },
        "node_sets": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1ClusterNodeSet"
          },
          "description": "Desired node sets of the cluster.\n\nThis will be automatically set by the system when the cluster is initially created, according to the template\nselected by the user, and can be later modified to change the size.\n\nThe key of the map is the unique identifier of the node set for this cluster.\n\nFor example, a cluster created with two different node sets, one for nodes without GPUs and another for nodes with\nGPUs could be represented like this:\n\n```json\n{\n  \"id\": \"123\",\n  \"spec\": {\n    \"node_sets\": {\n      \"compute\": {\n        \"host_class\": \"acme_1tb\",\n        \"size\": 3\n      },\n      \"gpu\": {\n        \"host_class\": \"acme_1tb_h100\",\n        \"size\": 3\n      }\n    }\n  },\n  \"status\": {\n    \"state\": \"CLUSTER_STATE_READY\",\n    \"node_sets\": {\n      \"compute\": {\n        \"host_class\": \"acme_1tb\",\n        \"size\": 3\n      },\n      \"gpu\": {\n        \"host_class\": \"acme_1tb_h100\",\n        \"size\": 3\n      }\n    }\n  }\n}\n```\n\nThe user will not be allowed to change the `host_class` field.\n\nThe user will be allowed to add new node sets.\n\nThe user will be allowed to remove existing node sets, except when only one node set remains. Clusters\nmust have at least one node set.\n\nThe user will be allowed to update `size` field.\n\nIf at any time the system can't allocate the number of nodes requested by the user, because of permissions, quota,\navailability of resources or system errors, the cluster will be marked as degraded, and the details will be in the\n`DEGRADED` condition."
        }
      },
      "description": "The spec contains the details of a cluster as desired by the user."
    },
    "v1ClusterState": {
      "type": "string",
      "enum": [
        "CLUSTER_STATE_UNSPECIFIED",
        "CLUSTER_STATE_PROGRESSING",
        "CLUSTER_STATE_READY",
        "CLUSTER_STATE_FAILED"
      ],
      "default": "CLUSTER_STATE_UNSPECIFIED",
      "description": "Represents the overall state of a cluster.\n\n - CLUSTER_STATE_UNSPECIFIED: Unspecified indicates that the state is unknown.\n - CLUSTER_STATE_PROGRESSING: Indicates that the cluster isn't ready yet.\n - CLUSTER_STATE_READY: Indicates indicates that the cluster is ready.\n - CLUSTER_STATE_FAILED: Indicates indicates that the cluster is unusable."
    },
    "v1ClusterStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1ClusterState",
          "description": "Indicates the overall state of the cluster."
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterCondition"
          },
          "description": "Contains a list of conditions that describe in detail the status of the cluster.\n\nFor example, an cluster that is ready could be represented like this (when converted to JSON):\n\n   {\n     \"id\": \"123\",\n     \"spec\": {\n     },\n     \"status\": {\n       \"state\": \"CLUSTER_STATE_READY\",\n       \"conditions\": [\n         {\n           \"type\": \"CLUSTER_CONDITION_TYPE_READY\",\n           \"status\": \"CONDITION_STATUS_TRUE\",\n           \"last_transition_time\": \"2025-03-12 20:15:59+00:00\",\n           \"message\": \"The cluster is ready to use\",\n         },\n         {\n           \"type\": \"CLUSTER_CONDITION_TYPE_FAILED\",\n           \"status\": \"CONDITION_STATUS_FALSE\",\n           \"last_transition_time\": \"2025-03-12 20:10:59+00:00\"\n         }\n       ]\n     }\n   }\n\nIn this example the `READY` condition is true. That tells us that the cluster is ready to use via the API URL\nprovided in the `status.api_url` field.\n\nThe `FAILED` condition is false. That tells us that the cluster is *not* failed.\n\nNote that in this example, to make it shorter, only one condition appears. In general all the conditions (except\n`UNSPECIFIED`) will appear exactly once.\n\nCheck the documentation of the values of the `ClusterConditionType` enumerated type to see possible conditions and\nreasons."
        },
        "api_url": {
          "type": "string",
          "description": "URL of te API server of the cluster.\n\nThis will be empty if the cluster isn't ready."
        },
        "console_url": {
          "type": "string",
          "description": "URL of the console of the cluster.\n\nThis will be empty if the cluster isn't ready or the console isn't enabled."
        },
        "node_sets": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1ClusterNodeSet"
          },
          "description": "Current node sets of the cluster.\n\nThis is the current status of the node sets. It will be different to `spec.node_sets` when there is a change that\nis in progress, or if the system can't apply the changes requested by the user.\n\nThe key of the map is the unique identifier of the node set for this cluster."
        }
      },
      "description": "The status contains the details of the cluster provided by the system."
    },
    "v1ClusterTemplate": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the template."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata"
        },
        "title": {
          "type": "string",
          "description": "Human friendly short description of the template, only a few words, suitable for displaying in one single line on a\nUI or CLI."
        },
        "description": {
          "type": "string",
          "description": "Human friendly long description of the template, using Markdown format."
        },
        "parameters": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterTemplateParameterDefinition"
          },
          "description": "Definitions of the parameters that can be used to customize the template.\n\nNote that these are only the *definitions* of the parameters, not the actual values. The actual values are in the\n`spec.template_parameters` field of the cluster."
        },
        "node_sets": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1ClusterTemplateNodeSet"
          },
          "description": "Initial node sets of the cluster."
        }
      },
      "description": "A cluster template defines a type of cluster that can be created by the user. Note that the user doesn't create these\ntemplates: the system provides a collection of them, and the user chooses one."
    },
    "v1ClusterTemplateNodeSet": {
      "type": "object",
      "properties": {
        "host_class": {
          "type": "string",
          "description": "Identifier of the class of hosts that are part of the set."
        },
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Number of nodes of the set."
        }
      },
      "description": "Defines a set of nodes that will be part of cluster, all of them of the same class of host."
    },
    "v1ClusterTemplateParameterDefinition": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the parameter.\n\nThis is the name that should be used in the `template_parameters` field of the cluster to assign a value to the\nparameter."
        },
        "title": {
          "type": "string",
          "description": "Human friendly short description of the parameter, only a few words, suitable for displaying in one single line on\na UI or CLI."
        },
        "description": {
          "type": "string",
          "description": "Human friendly description of the parameter, using Markdown format."
        },
        "required": {
          "type": "boolean",
          "description": "Indicates if this parameter is required or optional.\n\nValues for required parameters must be included when creating the cluster, otherwise it will be rejected.\n\nNote that there may be other dependencies between parameters which may cause a cluster to be rejected. For example,\nthe allowed values of a parameter may depend on the value of another parameter. That kind of information will be in\nthe `description` field."
        },
        "type": {
          "type": "string",
          "description": "Type of the parameter.\n\nThe possible values are the same as those used by the `type_url` field of the `Any` type:\n\n| Type                           | Value                                             |\n|--------------------------------|---------------------------------------------------|\n| Boolean                        | `type.googleapis.com/google.protobuf.BoolValue`   |\n| Integer number, 32 bits        | `type.googleapis.com/google.protobuf.Int32Value`  |\n| Integer number, 64 bits        | `type.googleapis.com/google.protobuf.Int64Value`  |\n| Floating point number, 32 bits | `type.googleapis.com/google.protobuf.FloatValue`  |\n| Floating point number, 64 bits | `type.googleapis.com/google.protobuf.DoubleValue` |\n| String                         | `type.googleapis.com/google.protobuf.StringValue` |\n| Timestamp                      | `type.googleapis.com/google.protobuf.Timestamp`   |\n| Duration                       | `type.googleapis.com/google.protobuf.Duration`    |\n| Array of bytes                 | `type.googleapis.com/google.protobuf.BytesValue`  |\n| Any JSON value                 | `type.googleapis.com/google.protobuf.Value`       |\n\nWhen using the HTTP+JSON version of the API the value provided in the `template_parameters` field of the cluster\nmust be represented as documented in the (ProtoJSON format document)[https://protobuf.dev/programming-guides/json]."
        },
        "default": {
          "$ref": "#/definitions/protobufAny",
          "description": "Default value for optional parameters."
        }
      },
      "description": "Contains type and documentation of a template parameter."
    },
    "v1ClusterTemplatesCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ClusterTemplate"
        }
      }
    },
    "v1ClusterTemplatesDeleteResponse": {
      "type": "object"
    },
    "v1ClusterTemplatesGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ClusterTemplate"
        }
      }
    },
    "v1ClusterTemplatesListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterTemplate"
          },
          "description": "List of results."
        }
      }
    },
    "v1ClusterTemplatesUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ClusterTemplate"
        }
      }
    },
    "v1ClustersCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1Cluster"
        }
      }
    },
    "v1ClustersDeleteResponse": {
      "type": "object"
    },
    "v1ClustersGetKubeconfigResponse": {
      "type": "object",
      "properties": {
        "kubeconfig": {
          "type": "string"
        }
      }
    },
    "v1ClustersGetPasswordResponse": {
      "type": "object",
      "properties": {
        "password": {
          "type": "string"
        }
      }
    },
    "v1ClustersGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1Cluster"
        }
      }
    },
    "v1ClustersListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Cluster"
          },
          "description": "List of results."
        }
      }
    },
    "v1ClustersUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1Cluster"
        }
      }
    },
    "v1ComputeInstance": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the compute instance."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata"
        },
        "spec": {
          "$ref": "#/definitions/v1ComputeInstanceSpec"
        },
        "status": {
          "$ref": "#/definitions/v1ComputeInstanceStatus"
        }
      },
      "description": "Contains the details of the compute instance.\n\nThe `spec` contains the desired details, and may be modified by the user. The `status` contains the current status of\nthe compute instance, is provided by the system and can't be modified by the user."
    },
    "v1ComputeInstanceCondition": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/v1ComputeInstanceConditionType",
          "description": "Indicates the type of condition."
        },
        "status": {
          "$ref": "#/definitions/v1ConditionStatus",
          "description": "Indicates the status of the condition."
        },
        "last_transition_time": {
          "type": "string",
          "format": "date-time",
          "description": "This time is the last time that the condition was updated."
        },
        "reason": {
          "type": "string",
          "description": "Contains a the reason of the condition in a format suitable for use by programs.\n\nThe possible values will be documented in the object that contains the condition."
        },
        "message": {
          "type": "string",
          "description": "Contains a text giving more details of the condition.\n\nThis will usually be progress reports, or error messages, and are intended for use by humans, to debug problems."
        }
      },
      "description": "Contains the details of a condition that describes the status of a compute instance."
    },
    "v1ComputeInstanceConditionType": {
      "type": "string",
      "enum": [
        "COMPUTE_INSTANCE_CONDITION_TYPE_UNSPECIFIED",
        "COMPUTE_INSTANCE_CONDITION_TYPE_PROGRESSING",
        "COMPUTE_INSTANCE_CONDITION_TYPE_AVAILABLE",
        "COMPUTE_INSTANCE_CONDITION_TYPE_FAILED",
        "COMPUTE_INSTANCE_CONDITION_TYPE_DEGRADED",
        "COMPUTE_INSTANCE_CONDITION_TYPE_RESTART_IN_PROGRESS",
        "COMPUTE_INSTANCE_CONDITION_TYPE_RESTART_FAILED"
      ],
      "default": "COMPUTE_INSTANCE_CONDITION_TYPE_UNSPECIFIED",
      "description": "Types of conditions used to describe the status of compute instance.\n\n - COMPUTE_INSTANCE_CONDITION_TYPE_UNSPECIFIED: Unspecified indicates that the condition is unknown.\n\nThis will never be appear in the `spec.conditions` field of a compute instance.\n - COMPUTE_INSTANCE_CONDITION_TYPE_PROGRESSING: Indicates that the compute instance isn't completely ready yet.\n\nCurrently there are no `reason` values defined.\n - COMPUTE_INSTANCE_CONDITION_TYPE_AVAILABLE: Indicates that the compute instance is available.\n\nCurrently there are no `reason` values defined.\n - COMPUTE_INSTANCE_CONDITION_TYPE_FAILED: Indicates that the compute instance is unusable.\n\nCurrently there are no `reason` values defined.\n - COMPUTE_INSTANCE_CONDITION_TYPE_DEGRADED: Indicates that the compute instance is degraded.\n - COMPUTE_INSTANCE_CONDITION_TYPE_RESTART_IN_PROGRESS: Indicates that a restart is in progress.\n\nWhen `status` is `TRUE`, it means a restart is currently in progress.\n\nPossible `reason` values:\n- `RestartRequested`: A restart has been requested via `spec.restart_requested_at`.\n- `RestartInProgress`: The restart has been initiated.\n\nWhen `status` is `FALSE`, no restart is currently in progress.\n - COMPUTE_INSTANCE_CONDITION_TYPE_RESTART_FAILED: Indicates that a restart request has failed.\n\nWhen `status` is `TRUE`, it means the restart could not be executed.\nThe `message` field will contain details about the failure.\nIf the issue persists, please contact your administrator.\n\nWhen `status` is `FALSE`, there is no restart failure."
    },
    "v1ComputeInstanceSpec": {
      "type": "object",
      "properties": {
        "template": {
          "type": "string",
          "description": "Reference to the compute instance template.\n\nThis is mandatory, and must be the value of the `id` field of one of the compute instance templates.\n\nThis can't be modified after the compute instance is created."
        },
        "template_parameters": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/protobufAny"
          },
          "description": "Values of the template parameters.\n\nWhen using the HTTP+JSON version of the API the values must be represented as documented in the (ProtoJSON format\ndocument)[https://protobuf.dev/programming-guides/json]. For example, if the template has a `cpu_count`\nparameter of integer type, the complete compute instance should be represented like this:\n\n```json\n{\n  \"spec\": {\n    \"template\": \"123\",\n    \"template_parameters\": {\n      \"cpu_count\": {\n        \"@type\": \"type.googleapis.com/google.protobuf.Int32Value\",\n        \"value\": 4\n      }\n    }\n  }\n}\n```\n\nThe possible values of the `@type` are the same as those used by the `type_url` field of the `Any` type:\n\n| Type                           | Value                                             |\n|--------------------------------|---------------------------------------------------|\n| Boolean                        | `type.googleapis.com/google.protobuf.BoolValue`   |\n| Integer number, 32 bits        | `type.googleapis.com/google.protobuf.Int32Value`  |\n| Integer number, 64 bits        | `type.googleapis.com/google.protobuf.Int64Value`  |\n| Floating point number, 32 bits | `type.googleapis.com/google.protobuf.FloatValue`  |\n| Floating point number, 64 bits | `type.googleapis.com/google.protobuf.DoubleValue` |\n| String                         | `type.googleapis.com/google.protobuf.StringValue` |\n| Timestamp                      | `type.googleapis.com/google.protobuf.Timestamp`   |\n| Duration                       | `type.googleapis.com/google.protobuf.Duration`    |\n| Array of bytes                 | `type.googleapis.com/google.protobuf.BytesValue`  |\n| Any JSON value                 | `type.googleapis.com/google.protobuf.Value`       |\n\nThese parameters can't be modified after the compute instance is created."
        },
        "restart_requested_at": {
          "type": "string",
          "format": "date-time",
          "description": "RestartRequestedAt is a timestamp signal to request a ComputeInstance restart.\n\nSet this field to the current time (usually NOW) to request a restart.\nThe controller will execute the restart if this timestamp is greater than\n`status.last_restarted_at`.\n\nThis is a declarative signal mechanism - the timestamp is a monotonically\nincreasing value to detect new restart requests, not a scheduled time.\nTypically set to the current time for immediate restarts.\n\nExternal schedulers can set this field on a schedule to implement\nscheduled maintenance windows if needed.\n\nExample (when converted to JSON):\n\n   {\n     \"spec\": {\n       \"template\": \"123\",\n       \"restart_requested_at\": \"2026-01-20T14:30:00Z\"\n     }\n   }"
        }
      },
      "description": "The spec contains the details of a compute instance as desired by the user."
    },
    "v1ComputeInstanceState": {
      "type": "string",
      "enum": [
        "COMPUTE_INSTANCE_STATE_UNSPECIFIED",
        "COMPUTE_INSTANCE_STATE_STARTING",
        "COMPUTE_INSTANCE_STATE_RUNNING",
        "COMPUTE_INSTANCE_STATE_FAILED",
        "COMPUTE_INSTANCE_STATE_DELETING"
      ],
      "default": "COMPUTE_INSTANCE_STATE_UNSPECIFIED",
      "description": "Represents the overall state of a compute instance.\n\n - COMPUTE_INSTANCE_STATE_UNSPECIFIED: Unspecified indicates that the state is unknown.\n - COMPUTE_INSTANCE_STATE_STARTING: Indicates that the compute instance is starting.\n - COMPUTE_INSTANCE_STATE_RUNNING: Indicates that the compute instance is running.\n - COMPUTE_INSTANCE_STATE_FAILED: Indicates that the compute instance is unusable.\n - COMPUTE_INSTANCE_STATE_DELETING: Indicates that the compute instance is being deleted."
    },
    "v1ComputeInstanceStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1ComputeInstanceState",
          "description": "Indicates the overall state of the compute instance."
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ComputeInstanceCondition"
          },
          "description": "Contains a list of conditions that describe in detail the status of the compute instance.\n\nFor example, a running compute instance could be represented like this (when converted to JSON):\n\n   {\n     \"id\": \"123\",\n     \"spec\": {\n     },\n     \"status\": {\n       \"state\": \"COMPUTE_INSTANCE_STATE_RUNNING\",\n       \"conditions\": [\n         {\n           \"type\": \"COMPUTE_INSTANCE_CONDITION_TYPE_AVAILABLE\",\n           \"status\": \"CONDITION_STATUS_TRUE\",\n           \"last_transition_time\": \"2025-03-12 20:15:59+00:00\",\n           \"message\": \"The compute instance is available\",\n         }\n       ]\n     }\n   }\n\nIn this example the `AVAILABLE` condition is true. That tells us that the compute instance is available via the IP address\nprovided in the `status.ip_address` field.\n\nNote that in this example, to make it shorter, only one condition appears. In general all the conditions (except\n`UNSPECIFIED`) will appear exactly once.\n\nCheck the documentation of the values of the `ComputeInstanceConditionType` enumerated type to see possible conditions and\nreasons."
        },
        "ip_address": {
          "type": "string",
          "description": "IP address of the compute instance.\n\nThis will be empty if the compute instance isn't running."
        },
        "last_restarted_at": {
          "type": "string",
          "format": "date-time",
          "description": "LastRestartedAt records when the last restart was initiated by the controller.\n\nThis is set to `spec.restart_requested_at` when the controller processes a restart request.\nIt will be empty if no restart has been performed yet.\n\nExample (when converted to JSON):\n\n   {\n     \"status\": {\n       \"state\": \"COMPUTE_INSTANCE_STATE_RUNNING\",\n       \"last_restarted_at\": \"2026-01-20T14:30:00Z\"\n     }\n   }"
        }
      },
      "description": "The status contains the details of the compute instance provided by the system."
    },
    "v1ComputeInstanceTemplate": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the template."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata"
        },
        "title": {
          "type": "string",
          "description": "Human friendly short description of the template, only a few words, suitable for displaying in one single line on a\nUI or CLI."
        },
        "description": {
          "type": "string",
          "description": "Human friendly long description of the template, using Markdown format."
        },
        "parameters": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ComputeInstanceTemplateParameterDefinition"
          },
          "description": "Definitions of the parameters that can be used to customize the template.\n\nNote that these are only the *definitions* of the parameters, not the actual values. The actual values are in the\n`spec.template_parameters` field of the compute instance."
        }
      },
      "description": "A compute instance template defines a type of compute instance that can be created by the user. Note that the user doesn't create these\ntemplates: the system provides a collection of them, and the user chooses one."
    },
    "v1ComputeInstanceTemplateParameterDefinition": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of the parameter.\n\nThis is the name that should be used in the `template_parameters` field of the compute instance to assign a value to the\nparameter."
        },
        "title": {
          "type": "string",
          "description": "Human friendly short description of the parameter, only a few words, suitable for displaying in one single line on\na UI or CLI."
        },
        "description": {
          "type": "string",
          "description": "Human friendly description of the parameter, using Markdown format."
        },
        "required": {
          "type": "boolean",
          "description": "Indicates if this parameter is required or optional.\n\nValues for required parameters must be included when creating the compute instance, otherwise it will be rejected.\n\nNote that there may be other dependencies between parameters which may cause a compute instance to be rejected. For example,\nthe allowed values of a parameter may depend on the value of another parameter. That kind of information will be in\nthe `description` field."
        },
        "type": {
          "type": "string",
          "description": "Type of the parameter.\n\nThe possible values are the same as those used by the `type_url` field of the `Any` type:\n\n| Type                           | Value                                             |\n|--------------------------------|---------------------------------------------------|\n| Boolean                        | `type.googleapis.com/google.protobuf.BoolValue`   |\n| Integer number, 32 bits        | `type.googleapis.com/google.protobuf.Int32Value`  |\n| Integer number, 64 bits        | `type.googleapis.com/google.protobuf.Int64Value`  |\n| Floating point number, 32 bits | `type.googleapis.com/google.protobuf.FloatValue`  |\n| Floating point number, 64 bits | `type.googleapis.com/google.protobuf.DoubleValue` |\n| String                         | `type.googleapis.com/google.protobuf.StringValue` |\n| Timestamp                      | `type.googleapis.com/google.protobuf.Timestamp`   |\n| Duration                       | `type.googleapis.com/google.protobuf.Duration`    |\n| Array of bytes                 | `type.googleapis.com/google.protobuf.BytesValue`  |\n| Any JSON value                 | `type.googleapis.com/google.protobuf.Value`       |\n\nWhen using the HTTP+JSON version of the API the value provided in the `template_parameters` field of the compute instance\nmust be represented as documented in the (ProtoJSON format document)[https://protobuf.dev/programming-guides/json]."
        },
        "default": {
          "$ref": "#/definitions/protobufAny",
          "description": "Default value for optional parameters."
        }
      },
      "description": "Contains type and documentation of a template parameter."
    },
    "v1ComputeInstanceTemplatesCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ComputeInstanceTemplate"
        }
      }
    },
    "v1ComputeInstanceTemplatesDeleteResponse": {
      "type": "object"
    },
    "v1ComputeInstanceTemplatesGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ComputeInstanceTemplate"
        }
      }
    },
    "v1ComputeInstanceTemplatesListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ComputeInstanceTemplate"
          },
          "description": "List of results."
        }
      }
    },
    "v1ComputeInstanceTemplatesUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ComputeInstanceTemplate"
        }
      }
    },
    "v1ComputeInstancesCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ComputeInstance"
        }
      }
    },
    "v1ComputeInstancesDeleteResponse": {
      "type": "object"
    },
    "v1ComputeInstancesGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ComputeInstance"
        }
      }
    },
    "v1ComputeInstancesListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ComputeInstance"
          },
          "description": "List of results."
        }
      }
    },
    "v1ComputeInstancesUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1ComputeInstance"
        }
      }
    },
    "v1ConditionStatus": {
      "type": "string",
      "enum": [
        "CONDITION_STATUS_UNSPECIFIED",
        "CONDITION_STATUS_TRUE",
        "CONDITION_STATUS_FALSE"
      ],
      "default": "CONDITION_STATUS_UNSPECIFIED",
      "description": " - CONDITION_STATUS_UNSPECIFIED: Indicates that the system can't decide if the object is in the condition or not.\n - CONDITION_STATUS_TRUE: Indicates that the object is in the condition.\n - CONDITION_STATUS_FALSE: Indicates that the object is not in the condition."
    },
    "v1Event": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the event."
        },
        "type": {
          "$ref": "#/definitions/v1EventType",
          "description": "Type of event."
        },
        "cluster": {
          "$ref": "#/definitions/v1Cluster"
        },
        "cluster_template": {
          "$ref": "#/definitions/v1ClusterTemplate"
        }
      },
      "description": "Represents events delivered by the server."
    },
    "v1EventType": {
      "type": "string",
      "enum": [
        "EVENT_TYPE_UNSPECIFIED",
        "EVENT_TYPE_OBJECT_CREATED",
        "EVENT_TYPE_OBJECT_UPDATED",
        "EVENT_TYPE_OBJECT_DELETED"
      ],
      "default": "EVENT_TYPE_UNSPECIFIED",
      "description": " - EVENT_TYPE_UNSPECIFIED: Unspecified means that the even type is unknown.\n - EVENT_TYPE_OBJECT_CREATED: Means that a new object has been created.\n\nThe payload will contain the representation of the object.\n - EVENT_TYPE_OBJECT_UPDATED: Means that an existing object has been modified.\n\nThe payload will contain the updated representation of the object.\n - EVENT_TYPE_OBJECT_DELETED: Means that an object has been deleted.\n\nThe payload will contain the representation of the object right before it was deleted."
    },
    "v1EventsWatchResponse": {
      "type": "object",
      "properties": {
        "event": {
          "$ref": "#/definitions/v1Event"
        }
      }
    },
    "v1Host": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the host."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata"
        },
        "spec": {
          "$ref": "#/definitions/v1HostSpec"
        },
        "status": {
          "$ref": "#/definitions/v1HostStatus"
        }
      },
      "description": "Contains the details of the host.\n\nThe `spec` contains the desired details, and may be modified by the user. The `status` contains the current status of\nthe host, is provided by the system and can't be modified by the user."
    },
    "v1HostClass": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the class."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata",
          "description": "Metadata of the host class."
        },
        "title": {
          "type": "string",
          "description": "Human friendly short description of the host class, only a few words, suitable for displaying in one single\nline on a UI or CLI."
        },
        "description": {
          "type": "string",
          "description": "Human friendly long description of the host class, using Markdown format."
        }
      },
      "description": "Describes a set of hosts that share characteristics.\n\nFor example there could be a host class `acme_1tb` to describe the set of hosts manifactured by ACME and with 1 TiB\nof RAM, and another `ibm_mi300x` to describe the set of hosts manufactured IBM and with a MI300X GPU.\n\nThis is similar to the _instance type_ concept used by many cloud providers.\n\nThe detailed chracteristics of the host (CPU, memory, GPU, etc) will be in the `description` field."
    },
    "v1HostClassesCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1HostClass"
        }
      }
    },
    "v1HostClassesDeleteResponse": {
      "type": "object"
    },
    "v1HostClassesGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1HostClass"
        }
      }
    },
    "v1HostClassesListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1HostClass"
          },
          "description": "List of results."
        }
      }
    },
    "v1HostClassesUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1HostClass"
        }
      }
    },
    "v1HostCondition": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/v1HostConditionType",
          "description": "Indicates the type of condition."
        },
        "status": {
          "$ref": "#/definitions/v1ConditionStatus",
          "description": "Indicates the status of the condition."
        },
        "last_transition_time": {
          "type": "string",
          "format": "date-time",
          "description": "This time is the last time that the condition was updated."
        },
        "reason": {
          "type": "string",
          "description": "Contains a the reason of the condition in a format suitable for use by programs.\n\nThe possible values will be documented in the object that contains the condition."
        },
        "message": {
          "type": "string",
          "description": "Contains a text giving more details of the condition.\n\nThis will usually be progress reports, or error messages, and are intended for use by humans, to debug problems."
        }
      },
      "description": "Contains the details of a condition that describes the status of a host."
    },
    "v1HostConditionType": {
      "type": "string",
      "enum": [
        "HOST_CONDITION_TYPE_UNSPECIFIED",
        "HOST_CONDITION_TYPE_PROGRESSING",
        "HOST_CONDITION_TYPE_READY",
        "HOST_CONDITION_TYPE_FAILED",
        "HOST_CONDITION_TYPE_DEGRADED"
      ],
      "default": "HOST_CONDITION_TYPE_UNSPECIFIED",
      "description": "Types of conditions used to describe the status of host.\n\n - HOST_CONDITION_TYPE_UNSPECIFIED: Unspecified indicates that the condition is unknown.\n\nThis will never be appear in the `spec.conditions` field of a host.\n - HOST_CONDITION_TYPE_PROGRESSING: Indicates that the host isn't completely ready yet.\n\nCurrently there are no `reason` values defined.\n - HOST_CONDITION_TYPE_READY: Indicates that the host is ready to use.\n\nCurrently there are no `reason` values defined.\n - HOST_CONDITION_TYPE_FAILED: Indicates that the host is unusable.\n\nCurrently there are no `reason` values defined.\n - HOST_CONDITION_TYPE_DEGRADED: Indicates that the host is degraded."
    },
    "v1HostPool": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the host pool."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata"
        },
        "spec": {
          "$ref": "#/definitions/v1HostPoolSpec"
        },
        "status": {
          "$ref": "#/definitions/v1HostPoolStatus"
        }
      },
      "description": "Contains the details of the host pool.\n\nThe `spec` contains the desired details, and may be modified by the user. The `status` contains the current status of\nthe host pool, is provided by the system and can't be modified by the user."
    },
    "v1HostPoolCondition": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/v1HostPoolConditionType",
          "description": "Indicates the type of condition."
        },
        "status": {
          "$ref": "#/definitions/v1ConditionStatus",
          "description": "Indicates the status of the condition."
        },
        "last_transition_time": {
          "type": "string",
          "format": "date-time",
          "description": "This time is the last time that the condition was updated."
        },
        "reason": {
          "type": "string",
          "description": "Contains a the reason of the condition in a format suitable for use by programs.\n\nThe possible values will be documented in the object that contains the condition."
        },
        "message": {
          "type": "string",
          "description": "Contains a text giving more details of the condition.\n\nThis will usually be progress reports, or error messages, and are intended for use by humans, to debug problems."
        }
      },
      "description": "Contains the details of a condition that describes the status of a host pool."
    },
    "v1HostPoolConditionType": {
      "type": "string",
      "enum": [
        "HOST_POOL_CONDITION_TYPE_UNSPECIFIED",
        "HOST_POOL_CONDITION_TYPE_PROGRESSING",
        "HOST_POOL_CONDITION_TYPE_READY",
        "HOST_POOL_CONDITION_TYPE_FAILED",
        "HOST_POOL_CONDITION_TYPE_DEGRADED"
      ],
      "default": "HOST_POOL_CONDITION_TYPE_UNSPECIFIED",
      "description": "Types of conditions used to describe the status of host pool.\n\n - HOST_POOL_CONDITION_TYPE_UNSPECIFIED: Unspecified indicates that the condition is unknown.\n\nThis will never be appear in the `spec.conditions` field of a host pool.\n - HOST_POOL_CONDITION_TYPE_PROGRESSING: Indicates that the host pool isn't completely ready yet.\n\nCurrently there are no `reason` values defined.\n - HOST_POOL_CONDITION_TYPE_READY: Indicates that the host pool is ready to use.\n\nCurrently there are no `reason` values defined.\n - HOST_POOL_CONDITION_TYPE_FAILED: Indicates that the host pool is unusable.\n\nCurrently there are no `reason` values defined.\n - HOST_POOL_CONDITION_TYPE_DEGRADED: Indicates that the host pool is degraded."
    },
    "v1HostPoolHostSet": {
      "type": "object",
      "properties": {
        "host_class": {
          "type": "string",
          "description": "Identifier of the class of hosts that are part of the set.\n\nThe details of the host class can be obtained using the `List` and `Get` method of the `HostClasses` service. For\nexample, to get the details of the `acme_1tb` host class using the HTTP+JSON version of the API:\n\n```http\nGET /api/fulfillment/v1/host_classes/acme_1tb\n```\n\nWhich will return something like this:\n\n```json\n{\n  \"id\": \"acme_1tb\",\n  \"title\": \"ACME server with 1 TiB of RAM and no GPU\",\n  \"description\": \"ACME server model XYZ with 1 TiB of RAM, 2 Xeon 6 CPUS and no GPU.\"\n}\n```\n\nThis will be set by the system when the host pool is initially created, according to the template selected by the\nuser.\n\nThe user will not have permission to change this field."
        },
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Number of hosts of the set."
        }
      },
      "description": "Defines a set of hosts that are part of the host pool, all of them of the same class of host."
    },
    "v1HostPoolSpec": {
      "type": "object",
      "properties": {
        "host_sets": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1HostPoolHostSet"
          },
          "description": "Desired host sets of the host pool.\n\nThe key of the map is the unique identifier of the host set for this host pool."
        }
      },
      "description": "The spec contains the details of a host pool as desired by the user."
    },
    "v1HostPoolState": {
      "type": "string",
      "enum": [
        "HOST_POOL_STATE_UNSPECIFIED",
        "HOST_POOL_STATE_PROGRESSING",
        "HOST_POOL_STATE_READY",
        "HOST_POOL_STATE_FAILED"
      ],
      "default": "HOST_POOL_STATE_UNSPECIFIED",
      "description": "Represents the overall state of a host pool.\n\n - HOST_POOL_STATE_UNSPECIFIED: Unspecified indicates that the state is unknown.\n - HOST_POOL_STATE_PROGRESSING: Indicates that the host pool isn't ready yet.\n - HOST_POOL_STATE_READY: Indicates indicates that the host pool is ready.\n - HOST_POOL_STATE_FAILED: Indicates indicates that the host pool is unusable."
    },
    "v1HostPoolStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1HostPoolState",
          "description": "Indicates the overall state of the host pool."
        },
        "hosts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "The ids of assigned Hosts;"
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1HostPoolCondition"
          },
          "description": "Contains a list of conditions that describe in detail the status of the host pool.\n\nFor example, a host pool that is ready could be represented like this (when converted to JSON):\n\n   {\n     \"id\": \"123\",\n     \"spec\": {\n     },\n     \"status\": {\n       \"state\": \"HOST_POOL_STATE_READY\",\n       \"conditions\": [\n         {\n           \"type\": \"HOST_POOL_CONDITION_TYPE_READY\",\n           \"status\": \"CONDITION_STATUS_TRUE\",\n           \"last_transition_time\": \"2025-03-12 20:15:59+00:00\",\n           \"message\": \"The host pool is ready to use\",\n         },\n         {\n           \"type\": \"HOST_POOL_CONDITION_TYPE_FAILED\",\n           \"status\": \"CONDITION_STATUS_FALSE\",\n           \"last_transition_time\": \"2025-03-12 20:10:59+00:00\"\n         }\n       ]\n     }\n   }\n\nIn this example the `READY` condition is true. That tells us that the host pool is ready to use via the API URL\nprovided in the `status.api_url` field.\n\nThe `FAILED` condition is false. That tells us that the host pool is *not* failed.\n\nNote that in this example, to make it shorter, only one condition appears. In general all the conditions (except\n`UNSPECIFIED`) will appear exactly once.\n\nCheck the documentation of the values of the `HostPoolConditionType` enumerated type to see possible conditions and\nreasons."
        },
        "host_sets": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1HostPoolHostSet"
          },
          "description": "Current host sets of the host pool.\n\nThis is the current status of the host sets. It will be different to `spec.host_sets` when there is a change that\nis in progress, or if the system can't apply the changes requested by the user.\n\nThe key of the map is the unique identifier of the host set for this host pool."
        }
      },
      "description": "The status contains the details of the host pool provided by the system."
    },
    "v1HostPoolsCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1HostPool"
        }
      }
    },
    "v1HostPoolsDeleteResponse": {
      "type": "object"
    },
    "v1HostPoolsGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1HostPool"
        }
      }
    },
    "v1HostPoolsListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1HostPool"
          },
          "description": "List of results."
        }
      }
    },
    "v1HostPoolsUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1HostPool"
        }
      }
    },
    "v1HostPowerState": {
      "type": "string",
      "enum": [
        "HOST_POWER_STATE_UNSPECIFIED",
        "HOST_POWER_STATE_ON",
        "HOST_POWER_STATE_OFF"
      ],
      "default": "HOST_POWER_STATE_UNSPECIFIED",
      "description": "Represents the power state of a host.\n\n - HOST_POWER_STATE_UNSPECIFIED: Unspecified indicates that the state is unknown.\n - HOST_POWER_STATE_ON: Indicates that the host is powered on.\n - HOST_POWER_STATE_OFF: Indicates that the host is powered off."
    },
    "v1HostSpec": {
      "type": "object",
      "properties": {
        "power_state": {
          "$ref": "#/definitions/v1HostPowerState",
          "title": "Desired power state"
        }
      },
      "description": "The spec contains the details of the host as desired by the user."
    },
    "v1HostState": {
      "type": "string",
      "enum": [
        "HOST_STATE_UNSPECIFIED",
        "HOST_STATE_PROGRESSING",
        "HOST_STATE_READY",
        "HOST_STATE_FAILED"
      ],
      "default": "HOST_STATE_UNSPECIFIED",
      "description": "Represents the overall state of a host.\n\n - HOST_STATE_UNSPECIFIED: Unspecified indicates that the state is unknown.\n - HOST_STATE_PROGRESSING: Indicates that the host isn't ready yet.\n - HOST_STATE_READY: Indicates indicates that the host is ready.\n - HOST_STATE_FAILED: Indicates indicates that the host is unusable."
    },
    "v1HostStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1HostState",
          "description": "Indicates the overall state of the host."
        },
        "power_state": {
          "$ref": "#/definitions/v1HostPowerState",
          "title": "Current power state"
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1HostCondition"
          },
          "description": "Contains a list of conditions that describe in detail the status of the host.\n\nFor example, a host that is ready could be represented like this (when converted to JSON):\n\n   {\n     \"id\": \"123\",\n     \"spec\": {\n     },\n     \"status\": {\n       \"state\": \"HOST_STATE_READY\",\n       \"conditions\": [\n         {\n           \"type\": \"HOST_CONDITION_TYPE_READY\",\n           \"status\": \"CONDITION_STATUS_TRUE\",\n           \"last_transition_time\": \"2025-03-12 20:15:59+00:00\",\n           \"message\": \"The host is ready to use\",\n         },\n         {\n           \"type\": \"HOST_CONDITION_TYPE_FAILED\",\n           \"status\": \"CONDITION_STATUS_FALSE\",\n           \"last_transition_time\": \"2025-03-12 20:10:59+00:00\"\n         }\n       ]\n     }\n   }\n\nIn this example the `READY` condition is true. That tells us that the host is ready to use via the API URL\nprovided in the `status.api_url` field.\n\nThe `FAILED` condition is false. That tells us that the host is *not* failed.\n\nNote that in this example, to make it shorter, only one condition appears. In general all the conditions (except\n`UNSPECIFIED`) will appear exactly once.\n\nCheck the documentation of the values of the `HostConditionType` enumerated type to see possible conditions and\nreasons."
        }
      },
      "description": "The spec contains the details of the host as desired by the user."
    },
    "v1HostsCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1Host"
        }
      }
    },
    "v1HostsDeleteResponse": {
      "type": "object"
    },
    "v1HostsGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1Host"
        }
      }
    },
    "v1HostsListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or of the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Host"
          },
          "description": "List of results."
        }
      }
    },
    "v1HostsUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1Host"
        }
      }
    },
    "v1Metadata": {
      "type": "object",
      "properties": {
        "creation_timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "Time of creation of the object."
        },
        "deletion_timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "Time of deletion of the object."
        },
        "creators": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Names of the creators of the object."
        },
        "name": {
          "type": "string",
          "description": "Human friendly name of the object.\n\nHas the same restrictions than DNS labels, as described in RFC 1035:\n\n- Must be between 1 and 63 characters long.\n- Must only contain letters (a-z), digits (0-9) and hyphens (-).\n- It isn't case sensitive.\n\nIt is optional and not unique, so multiple objecs, even created by the same user or tenant, can have the same name."
        },
        "tenants": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Identifiers of the tenants that the object is assigned to."
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels contains key-value pairs for organizing and selecting objects.\n\nKeys consist of an optional prefix and a name separated by '/':\n\n- Prefix is a DNS subdomain (RFC 1035) and must be between 1 and 253 characters long.\n- Name must be between 1 and 63 characters long, start and end with an alphanumeric character, and contain only\n  letters (a-z), digits (0-9), '-' '_' or '.'.\n\nValues are optional; when present they must be between 0 and 63 characters long and follow the same character\nrules as names.\n\nLabels are indexed and searchable."
        },
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Annotations contains arbitrary metadata for objects.\n\nKeys follow the same rules as label keys, including the optional DNS subdomain prefix and the 1-63 character name\nrestrictions. Values can be any string."
        }
      },
      "description": "Metadata common to all kinds of objects."
    },
    "v1MetadataGetResponse": {
      "type": "object",
      "properties": {
        "authn": {
          "$ref": "#/definitions/v1Authn"
        }
      }
    },
    "v1NetworkClass": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the network class."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata",
          "description": "Metadata of the network class."
        },
        "title": {
          "type": "string",
          "description": "Human friendly short description of the network class, only a few words, suitable for displaying in one single\nline on a UI or CLI. For example: \"UDN Network\" or \"Physical Network\"."
        },
        "description": {
          "type": "string",
          "description": "Human friendly long description of the network class, using Markdown format. This should explain the\ncharacteristics of networks created using this class, including performance characteristics, isolation\nguarantees, and any limitations or requirements."
        },
        "implementation_strategy": {
          "type": "string",
          "description": "Implementation strategy identifier for this network class. This is the discriminator that VirtualNetwork\nresources use to select which network backend to use. For example: \"udn-net\", \"phys-net\", \"ovn-kubernetes\".\n\nThis value is system-defined and immutable once the NetworkClass is created."
        },
        "constraints": {
          "$ref": "#/definitions/v1NetworkClassConstraints",
          "description": "Class-specific configuration constraints and options. These define implementation-specific parameters that\nnetworks using this class must or may configure."
        },
        "capabilities": {
          "$ref": "#/definitions/v1NetworkClassCapabilities",
          "description": "Capabilities that this network class supports. These describe what features are available when using this\nnetwork implementation strategy."
        },
        "status": {
          "$ref": "#/definitions/v1NetworkClassStatus",
          "description": "Current operational status of the network class."
        }
      },
      "description": "Describes a network implementation strategy available for creating virtual networks.\n\nNetworkClass represents a specific network backend implementation that VirtualNetworks can use. For example,\nthere could be a network class `udn-net` to describe networks implemented using User-Defined Networks in\nKubernetes, and another `phys-net` for networks backed by physical network infrastructure.\n\nThis is similar to the _storage class_ concept used by Kubernetes for persistent volumes, or the _instance type_\nconcept used by cloud providers for compute resources.\n\nUsers query available NetworkClasses to discover which network implementation strategies they can choose when\ncreating VirtualNetworks. The `implementation_strategy` field is the key identifier that VirtualNetwork resources\nreference to select their network backend."
    },
    "v1NetworkClassCapabilities": {
      "type": "object",
      "properties": {
        "supports_ipv4": {
          "type": "boolean",
          "description": "Whether this network class supports IPv4 addressing."
        },
        "supports_ipv6": {
          "type": "boolean",
          "description": "Whether this network class supports IPv6 addressing."
        },
        "supports_dual_stack": {
          "type": "boolean",
          "description": "Whether this network class supports dual-stack (IPv4 + IPv6) configuration."
        }
      },
      "description": "Describes the capabilities supported by a NetworkClass.\n\nThese fields indicate what network features are available when using this class for VirtualNetwork creation."
    },
    "v1NetworkClassConstraints": {
      "type": "object",
      "description": "Defines configuration constraints for a specific NetworkClass implementation.\n\nThis message contains implementation-specific parameters that may be required or optional when creating\nVirtualNetworks using this class. Currently minimal to allow for future extension.\n\nReserved for future implementation-specific constraint fields.\n Examples might include: required VLAN ranges, MTU constraints, required subnet sizes, etc."
    },
    "v1NetworkClassState": {
      "type": "string",
      "enum": [
        "NETWORK_CLASS_STATE_UNSPECIFIED",
        "NETWORK_CLASS_STATE_PENDING",
        "NETWORK_CLASS_STATE_READY",
        "NETWORK_CLASS_STATE_FAILED"
      ],
      "default": "NETWORK_CLASS_STATE_UNSPECIFIED",
      "description": "Lifecycle states for NetworkClass resources.\n\n - NETWORK_CLASS_STATE_UNSPECIFIED: State is unknown or has not been determined yet.\n - NETWORK_CLASS_STATE_PENDING: The network class is being initialized and is not yet ready for use.\n - NETWORK_CLASS_STATE_READY: The network class is fully operational and available for creating VirtualNetworks.\n - NETWORK_CLASS_STATE_FAILED: The network class has encountered an error and cannot be used for creating VirtualNetworks."
    },
    "v1NetworkClassStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1NetworkClassState",
          "description": "Current lifecycle state of the network class."
        },
        "message": {
          "type": "string",
          "description": "Human-readable message providing additional details about the current state. For example, if the state is\nFAILED, this message might explain what went wrong."
        }
      },
      "description": "Represents the current operational state of a NetworkClass."
    },
    "v1NetworkClassesCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1NetworkClass"
        }
      }
    },
    "v1NetworkClassesDeleteResponse": {
      "type": "object"
    },
    "v1NetworkClassesGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1NetworkClass"
        }
      }
    },
    "v1NetworkClassesListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or if the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1NetworkClass"
          },
          "description": "List of results."
        }
      }
    },
    "v1NetworkClassesUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1NetworkClass"
        }
      }
    },
    "v1Protocol": {
      "type": "string",
      "enum": [
        "PROTOCOL_UNSPECIFIED",
        "PROTOCOL_TCP",
        "PROTOCOL_UDP",
        "PROTOCOL_ICMP",
        "PROTOCOL_ALL"
      ],
      "default": "PROTOCOL_UNSPECIFIED",
      "description": "Network protocol types for SecurityRule matching.\n\nDetermines which layer 4 protocol the rule applies to. Protocol affects whether port range fields are\napplicable (TCP/UDP) or ignored (ICMP/ALL).\n\n - PROTOCOL_UNSPECIFIED: Unknown protocol (invalid). This should never be used in actual rules.\n - PROTOCOL_TCP: TCP protocol. Port ranges (port_from, port_to) are required for TCP rules.\n\nUsed for connection-oriented protocols like HTTP, HTTPS, SSH, database connections, etc.\n - PROTOCOL_UDP: UDP protocol. Port ranges (port_from, port_to) are required for UDP rules.\n\nUsed for connectionless protocols like DNS, NTP, DHCP, VoIP, etc.\n - PROTOCOL_ICMP: ICMP protocol (ping and other control messages). Port ranges are not applicable.\n\nUsed for network diagnostics (ping), error reporting, and control messages.\n - PROTOCOL_ALL: All protocols (wildcard). Port ranges are not applicable.\n\nMatches any protocol. Useful for allowing all traffic from a trusted CIDR block or for egress rules\nthat permit all outbound traffic."
    },
    "v1SecurityGroup": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the security group."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata",
          "description": "Metadata of the security group, including name, labels, tenants, and timestamps.\n\nThe parent VirtualNetwork relationship should be specified via metadata.annotations using the\n'osac.io/owner-reference' key with the VirtualNetwork ID as the value. This establishes resource\nhierarchy for garbage collection."
        },
        "spec": {
          "$ref": "#/definitions/v1SecurityGroupSpec",
          "description": "Desired configuration of the security group (user-modifiable)."
        },
        "status": {
          "$ref": "#/definitions/v1SecurityGroupStatus",
          "description": "Current state of the security group (system-provided, read-only)."
        }
      },
      "description": "Represents a virtual firewall controlling network traffic for compute instances.\n\nSecurityGroup acts as a stateful firewall that controls inbound (ingress) and outbound (egress) traffic for\ncompute instances within a VirtualNetwork. Rules are stateful, meaning return traffic is automatically allowed\nfor established connections.\n\nSecurityGroups follow a default-deny policy: if no rules match, traffic is blocked. This ensures secure-by-default\nbehavior where only explicitly allowed traffic can pass through.\n\nSecurityGroups are scoped to a VirtualNetwork and can be attached to multiple compute instances within that\nnetwork. They cannot be used across different VirtualNetworks.\n\nThe parent VirtualNetwork relationship is established via metadata.annotations using the 'osac.io/owner-reference'\nkey with the VirtualNetwork ID as the value. This enables proper resource hierarchy for garbage collection - when\na VirtualNetwork is deleted, all associated SecurityGroups are automatically cleaned up.\n\nDesign follows AWS Security Groups and Azure Network Security Groups (NSGs) patterns, adapted for cloud-native\nmulti-tenant environments."
    },
    "v1SecurityGroupSpec": {
      "type": "object",
      "properties": {
        "virtual_network": {
          "type": "string",
          "description": "Parent VirtualNetwork ID for this security group.\n\nMust reference the ID of an existing VirtualNetwork in READY state. Security groups are scoped to a\nVirtualNetwork and can only be applied to compute instances within that network. This field is required\nand immutable after creation.\n\nExample: \"vnet-12345abc\""
        },
        "ingress": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1SecurityRule"
          },
          "description": "List of rules controlling inbound traffic to compute instances.\n\nRules are evaluated in order; first matching rule determines whether traffic is allowed. If no rules\nmatch, traffic is denied by default.\n\nExample: Allow SSH from specific CIDR, allow HTTP/HTTPS from anywhere, allow ICMP ping"
        },
        "egress": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1SecurityRule"
          },
          "description": "List of rules controlling outbound traffic from compute instances.\n\nRules are evaluated in order; first matching rule determines whether traffic is allowed. If no rules\nmatch, traffic is denied by default.\n\nExample: Allow all outbound traffic, or restrict to specific destinations"
        }
      },
      "description": "Defines the desired configuration for a SecurityGroup.\n\nThe spec contains user-specified firewall rules that define allowed network traffic. Rules are evaluated\nin order, and the first matching rule determines whether traffic is allowed. If no rules match, traffic\nis denied by default."
    },
    "v1SecurityGroupState": {
      "type": "string",
      "enum": [
        "SECURITY_GROUP_STATE_UNSPECIFIED",
        "SECURITY_GROUP_STATE_PENDING",
        "SECURITY_GROUP_STATE_READY",
        "SECURITY_GROUP_STATE_FAILED"
      ],
      "default": "SECURITY_GROUP_STATE_UNSPECIFIED",
      "description": "Lifecycle states for SecurityGroup resources.\n\nState transitions typically follow: UNSPECIFIED -\u003e PENDING -\u003e READY, with FAILED as a terminal error state\nthat may require user intervention or resource recreation.\n\n - SECURITY_GROUP_STATE_UNSPECIFIED: State is unknown or has not been determined yet. This is the default state before initialization.\n - SECURITY_GROUP_STATE_PENDING: The security group is being initialized and is not ready for use yet.\n\nDuring this state, the system is:\n- Validating firewall rules (port ranges, CIDR notation)\n- Checking parent VirtualNetwork exists and is in READY state\n- Configuring firewall backend\n- Installing rules in the network infrastructure\n\nSecurity groups in PENDING state cannot be attached to compute instances.\n - SECURITY_GROUP_STATE_READY: The security group is fully operational and ready for compute instances to use.\n\nIn this state:\n- All rules are validated and active\n- Firewall backend is configured\n- Security group can be attached to compute instances\n- Traffic filtering is enforced according to the rules\n - SECURITY_GROUP_STATE_FAILED: The security group has encountered an error and is unusable.\n\nCommon failure reasons include:\n- Invalid port range (port_from \u003e port_to, or values outside 1-65535)\n- Invalid CIDR notation\n- Parent VirtualNetwork does not exist\n- Parent VirtualNetwork is not in READY state\n- Protocol tcp/udp missing required port fields\n- Firewall backend configuration error\n\nThe status.message field will contain specific error details. Failed security groups typically require\ndeletion and recreation with corrected parameters, or resolution of the parent VirtualNetwork issue."
    },
    "v1SecurityGroupStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1SecurityGroupState",
          "description": "Current lifecycle state of the security group."
        },
        "message": {
          "type": "string",
          "description": "Human-readable message providing additional details about the current state.\n\nFor PENDING state, this might contain progress information like \"Validating rules\" or \"Configuring\nfirewall backend\".\n\nFor FAILED state, this contains error details explaining what went wrong, such as:\n- \"Invalid port range: port_from (100) \u003e port_to (50)\"\n- \"Parent VirtualNetwork not found: vnet-12345\"\n- \"Parent VirtualNetwork not in READY state\"\n- \"Invalid IPv4 CIDR: 192.168.1.0/33\"\n- \"Protocol tcp requires port_from and port_to fields\"\n\nFor READY state, this is typically empty or contains confirmation like \"Security group active, rules\nenforced\"."
        }
      },
      "description": "Represents the current operational state of a SecurityGroup.\n\nStatus is system-provided and read-only. Users cannot modify status fields directly; the system updates\nthem based on the reconciliation of the spec and the state of the parent VirtualNetwork."
    },
    "v1SecurityGroupsCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1SecurityGroup"
        }
      }
    },
    "v1SecurityGroupsDeleteResponse": {
      "type": "object"
    },
    "v1SecurityGroupsGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1SecurityGroup"
        }
      }
    },
    "v1SecurityGroupsListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or if the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1SecurityGroup"
          },
          "description": "List of results."
        }
      }
    },
    "v1SecurityGroupsUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1SecurityGroup"
        }
      }
    },
    "v1SecurityRule": {
      "type": "object",
      "properties": {
        "protocol": {
          "$ref": "#/definitions/v1Protocol",
          "description": "Protocol to match for this rule.\n\nUse PROTOCOL_ALL to match all protocols (wildcard). Use PROTOCOL_TCP or PROTOCOL_UDP when port ranges\nare needed. Use PROTOCOL_ICMP for ping and other ICMP traffic."
        },
        "port_from": {
          "type": "integer",
          "format": "int32",
          "description": "Starting port number for the rule (1-65535).\n\nRequired for tcp/udp protocols, ignored for icmp/all. For single port, set port_from = port_to.\nMust be \u003c= port_to. Validation enforced at service layer.\n\nExample: 22 (SSH), 80 (HTTP), 443 (HTTPS), 3306 (MySQL)"
        },
        "port_to": {
          "type": "integer",
          "format": "int32",
          "description": "Ending port number for the rule (1-65535).\n\nRequired for tcp/udp protocols, ignored for icmp/all. Must be \u003e= port_from. For single port, set\nport_from = port_to. Validation enforced at service layer.\n\nExample: 22 (single port), 8000 (range 8000-9000)"
        },
        "ipv4_cidr": {
          "type": "string",
          "description": "IPv4 CIDR block for source (ingress) or destination (egress) addresses.\n\nMust be valid CIDR notation. Use '0.0.0.0/0' to match all IPv4 addresses. Validation enforced at\nservice layer.\n\nExample: '192.168.1.0/24', '10.0.0.0/8', '0.0.0.0/0' (all IPv4)"
        },
        "ipv6_cidr": {
          "type": "string",
          "description": "IPv6 CIDR block for source (ingress) or destination (egress) addresses.\n\nMust be valid CIDR notation. Use '::/0' to match all IPv6 addresses. Validation enforced at service\nlayer.\n\nExample: '2001:db8::/32', 'fd00::/64', '::/0' (all IPv6)"
        }
      },
      "description": "Defines a single firewall rule for network traffic filtering.\n\nSecurityRule specifies which traffic to allow based on protocol, port ranges (for TCP/UDP), and source/\ndestination CIDR blocks. Rules are stateful - return traffic for established connections is automatically\nallowed.\n\nPort ranges apply only to TCP and UDP protocols. For ICMP and ALL protocols, port fields are ignored.\n\nCIDR fields support IPv4-only, IPv6-only, or dual-stack configurations:\n- IPv4-only: Set ipv4_cidr, leave ipv6_cidr empty\n- IPv6-only: Set ipv6_cidr, leave ipv4_cidr empty\n- Dual-stack: Set both ipv4_cidr and ipv6_cidr (creates two separate rules internally)"
    },
    "v1Subnet": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the subnet."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata",
          "description": "Metadata of the subnet, including name, labels, tenants, and timestamps.\n\nThe parent VirtualNetwork relationship should be specified via metadata.annotations using the\n'osac.io/owner-reference' key with the VirtualNetwork ID as the value. This establishes resource\nhierarchy for garbage collection."
        },
        "spec": {
          "$ref": "#/definitions/v1SubnetSpec",
          "description": "Desired configuration of the subnet (user-modifiable)."
        },
        "status": {
          "$ref": "#/definitions/v1SubnetStatus",
          "description": "Current state of the subnet (system-provided, read-only)."
        }
      },
      "description": "Represents a subdivision of a VirtualNetwork for organizing compute instances.\n\nSubnets subdivide VirtualNetwork IP address space into smaller, manageable segments. Each Subnet belongs to exactly\none parent VirtualNetwork and must be in the same region. Initially, the system supports a 1:1 mapping between\nVirtualNetwork and Subnet (one subnet per network), but the schema is designed to support multiple subnets per\nVirtualNetwork in the future.\n\nSubnets support flexible IP addressing to match the parent VirtualNetwork's capabilities:\n- IPv4-only: Set ipv4_cidr, leave ipv6_cidr empty\n- IPv6-only: Set ipv6_cidr, leave ipv4_cidr empty\n- Dual-stack: Set both ipv4_cidr and ipv6_cidr\n\nThe parent VirtualNetwork relationship should be specified via metadata.annotations using the 'osac.io/owner-reference'\nkey with the VirtualNetwork ID as the value. This establishes resource hierarchy for garbage collection, ensuring\nthat Subnets are automatically cleaned up when their parent VirtualNetwork is deleted.\n\nCIDR blocks must be non-overlapping within the same VirtualNetwork. Each Subnet's CIDR must be a subset of the\nparent VirtualNetwork's CIDR. Validation is enforced at the service layer."
    },
    "v1SubnetSpec": {
      "type": "object",
      "properties": {
        "virtual_network": {
          "type": "string",
          "description": "Parent VirtualNetwork ID. Required and immutable after creation.\n\nMust reference the ID of an existing VirtualNetwork in READY state. This field is required and immutable\nafter creation. The referenced VirtualNetwork must be in the same region as this Subnet.\n\nThe system validates that:\n- The VirtualNetwork exists\n- The VirtualNetwork.status.state is READY\n- The Subnet's CIDR blocks are subsets of the VirtualNetwork's CIDR blocks\n- The Subnet's CIDR blocks do not overlap with other Subnets in the same VirtualNetwork\n\nExample: \"vnet-abc123\""
        },
        "ipv4_cidr": {
          "type": "string",
          "description": "IPv4 CIDR block for this subnet. Optional for IPv6-only subnets.\n\nMust be valid CIDR notation and a subset of the parent VirtualNetwork.spec.ipv4_cidr. Validation enforced\nat service layer. The CIDR block must not overlap with other Subnets within the same VirtualNetwork.\n\nExample: \"10.0.1.0/24\", \"192.168.100.0/24\"\n\nLeave empty for IPv6-only subnets."
        },
        "ipv6_cidr": {
          "type": "string",
          "description": "IPv6 CIDR block for this subnet. Optional for IPv4-only subnets.\n\nMust be valid CIDR notation and a subset of the parent VirtualNetwork.spec.ipv6_cidr. Validation enforced\nat service layer. The CIDR block must not overlap with other Subnets within the same VirtualNetwork.\n\nExample: \"2001:db8::/64\", \"fd00:1234::/64\"\n\nLeave empty for IPv4-only subnets."
        }
      },
      "description": "Defines the desired configuration for a Subnet.\n\nThe spec contains user-specified parameters that define how the subnet should be configured. These fields\nfollow a declarative model where users specify the desired state and the system reconciles to match it."
    },
    "v1SubnetState": {
      "type": "string",
      "enum": [
        "SUBNET_STATE_UNSPECIFIED",
        "SUBNET_STATE_PENDING",
        "SUBNET_STATE_READY",
        "SUBNET_STATE_FAILED"
      ],
      "default": "SUBNET_STATE_UNSPECIFIED",
      "description": "Lifecycle states for Subnet resources.\n\nState transitions typically follow: UNSPECIFIED -\u003e PENDING -\u003e READY, with FAILED as a terminal error state\nthat may require user intervention or resource recreation.\n\n - SUBNET_STATE_UNSPECIFIED: State is unknown or has not been determined yet. This is the default state before initialization.\n - SUBNET_STATE_PENDING: The subnet is being initialized and is not ready for use yet.\n\nDuring this state, the system is:\n- Validating that the parent VirtualNetwork exists and is in READY state\n- Validating CIDR blocks (format, subset of parent, no overlaps)\n- Allocating IP address space within the parent VirtualNetwork\n- Configuring subnet routing and network policies\n\nCompute instances cannot be attached to subnets in PENDING state.\n - SUBNET_STATE_READY: The subnet is fully operational and ready for compute instances to attach.\n\nIn this state:\n- CIDR blocks are allocated and validated\n- Parent VirtualNetwork is in READY state\n- Subnet routing is configured\n- Compute instances can be created and attached\n- IP address allocation is active\n - SUBNET_STATE_FAILED: The subnet has encountered an error and is unusable.\n\nCommon failure reasons include:\n- Invalid CIDR notation\n- CIDR block is not a subset of parent VirtualNetwork CIDR\n- CIDR block overlaps with existing subnets in the same VirtualNetwork\n- Parent VirtualNetwork not found\n- Parent VirtualNetwork not in READY state\n- Network configuration error\n\nThe status.message field will contain specific error details. Failed subnets typically require deletion\nand recreation with corrected parameters."
    },
    "v1SubnetStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1SubnetState",
          "description": "Current lifecycle state of the subnet."
        },
        "message": {
          "type": "string",
          "description": "Human-readable message providing additional details about the current state.\n\nFor PENDING state, this might contain progress information like \"Validating CIDR blocks\" or\n\"Configuring subnet routing\".\n\nFor FAILED state, contains error details like:\n- \"CIDR overlaps with existing subnet\"\n- \"Parent VirtualNetwork not found\"\n- \"CIDR is not a subset of parent VirtualNetwork CIDR\"\n- \"Invalid CIDR notation\"\n- \"Parent VirtualNetwork not in READY state\"\n\nFor READY state, this is typically empty or contains confirmation like \"Subnet ready for compute instances\"."
        }
      },
      "description": "Represents the current operational state of a Subnet.\n\nStatus is system-provided and read-only. Users cannot modify status fields directly; the system updates them\nbased on the reconciliation of the spec."
    },
    "v1SubnetsCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1Subnet"
        }
      }
    },
    "v1SubnetsDeleteResponse": {
      "type": "object"
    },
    "v1SubnetsGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1Subnet"
        }
      }
    },
    "v1SubnetsListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or if the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Subnet"
          },
          "description": "List of results."
        }
      }
    },
    "v1SubnetsUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1Subnet"
        }
      }
    },
    "v1VirtualNetwork": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier of the virtual network."
        },
        "metadata": {
          "$ref": "#/definitions/v1Metadata",
          "description": "Metadata of the virtual network, including name, labels, tenants, and timestamps."
        },
        "spec": {
          "$ref": "#/definitions/v1VirtualNetworkSpec",
          "description": "Desired configuration of the virtual network (user-modifiable)."
        },
        "status": {
          "$ref": "#/definitions/v1VirtualNetworkStatus",
          "description": "Current state of the virtual network (system-provided, read-only)."
        }
      },
      "description": "Represents a tenant-isolated virtual network.\n\nVirtualNetwork provides network isolation for compute instances within a region. Each VirtualNetwork is backed\nby a specific NetworkClass implementation strategy (e.g., \"udn-net\" for User-Defined Networks, \"phys-net\" for\nphysical network infrastructure).\n\nVirtualNetworks support flexible IP addressing:\n- IPv4-only: Set ipv4_cidr, leave ipv6_cidr empty\n- IPv6-only: Set ipv6_cidr, leave ipv4_cidr empty\n- Dual-stack: Set both ipv4_cidr and ipv6_cidr\n\nThe selected NetworkClass must support the requested IP addressing mode via its capabilities.\n\nTenant isolation is enforced via the standard shared.v1.Metadata tenants field. VirtualNetworks are scoped to\na single region and cannot span multiple regions."
    },
    "v1VirtualNetworkCapabilities": {
      "type": "object",
      "properties": {
        "enable_ipv4": {
          "type": "boolean",
          "description": "Whether IPv4 is enabled for this network. Should be true when ipv4_cidr is set."
        },
        "enable_ipv6": {
          "type": "boolean",
          "description": "Whether IPv6 is enabled for this network. Should be true when ipv6_cidr is set."
        },
        "enable_dual_stack": {
          "type": "boolean",
          "description": "Whether dual-stack mode (both IPv4 and IPv6) is enabled. Should be true when both ipv4_cidr and ipv6_cidr\nare set."
        }
      },
      "description": "Describes the IP addressing capabilities requested for a VirtualNetwork.\n\nThese flags must be compatible with the selected NetworkClass.capabilities. For example, if enable_dual_stack\nis true, the selected NetworkClass must have supports_dual_stack set to true."
    },
    "v1VirtualNetworkSpec": {
      "type": "object",
      "properties": {
        "region": {
          "type": "string",
          "description": "Region where the network is created. This is required and immutable after creation.\n\nVirtualNetworks are region-scoped resources and cannot span multiple regions. Compute instances can only\nattach to VirtualNetworks in the same region.\n\nExample: \"us-east-1\", \"eu-west-2\""
        },
        "network_class": {
          "type": "string",
          "description": "NetworkClass implementation strategy to use for this network.\n\nThis references the `implementation_strategy` field of a NetworkClass resource. The selected NetworkClass\ndetermines the underlying network backend (e.g., \"udn-net\", \"phys-net\") and the available capabilities.\n\nThe NetworkClass must support the requested IP addressing capabilities (IPv4, IPv6, or dual-stack) specified\nvia the capabilities field.\n\nThis field is required and immutable after creation.\n\nExample: \"udn-net\", \"phys-net\", \"ovn-kubernetes\""
        },
        "ipv4_cidr": {
          "type": "string",
          "description": "IPv4 CIDR block for this network. Optional for IPv6-only networks.\n\nMust be valid CIDR notation. Validation enforced at service layer.\nThe CIDR block should be appropriately sized for the expected number of compute instances.\n\nExample: \"10.0.0.0/16\", \"192.168.0.0/24\"\n\nLeave empty when creating an IPv6-only network."
        },
        "ipv6_cidr": {
          "type": "string",
          "description": "IPv6 CIDR block for this network. Optional for IPv4-only networks.\n\nMust be valid CIDR notation. Validation enforced at service layer.\nIPv6 addresses should follow standard allocation practices for tenant networks.\n\nExample: \"2001:db8::/48\", \"fd00::/64\"\n\nLeave empty when creating an IPv4-only network."
        },
        "capabilities": {
          "$ref": "#/definitions/v1VirtualNetworkCapabilities",
          "description": "Requested network capabilities for this VirtualNetwork.\n\nThese capabilities must be compatible with the selected NetworkClass.capabilities. The system will validate\nthat the NetworkClass supports the requested addressing mode before creating the network."
        }
      },
      "description": "Defines the desired configuration for a VirtualNetwork.\n\nThe spec contains user-specified parameters that define how the network should be configured. These fields\nfollow a declarative model where users specify the desired state and the system reconciles to match it."
    },
    "v1VirtualNetworkState": {
      "type": "string",
      "enum": [
        "VIRTUAL_NETWORK_STATE_UNSPECIFIED",
        "VIRTUAL_NETWORK_STATE_PENDING",
        "VIRTUAL_NETWORK_STATE_READY",
        "VIRTUAL_NETWORK_STATE_FAILED"
      ],
      "default": "VIRTUAL_NETWORK_STATE_UNSPECIFIED",
      "description": "Lifecycle states for VirtualNetwork resources.\n\nState transitions typically follow: UNSPECIFIED -\u003e PENDING -\u003e READY, with FAILED as a terminal error state\nthat may require user intervention or resource recreation.\n\n - VIRTUAL_NETWORK_STATE_UNSPECIFIED: State is unknown or has not been determined yet. This is the default state before initialization.\n - VIRTUAL_NETWORK_STATE_PENDING: The virtual network is being initialized and is not ready for use yet.\n\nDuring this state, the system is:\n- Validating CIDR blocks\n- Checking NetworkClass compatibility\n- Allocating IP address space\n- Configuring the network backend\n\nCompute instances cannot be attached to networks in PENDING state.\n - VIRTUAL_NETWORK_STATE_READY: The virtual network is fully operational and ready for compute instances to attach.\n\nIn this state:\n- CIDR blocks are allocated and configured\n- Network backend is ready\n- Compute instances can be created and attached\n- Network isolation and routing are active\n - VIRTUAL_NETWORK_STATE_FAILED: The virtual network has encountered an error and is unusable.\n\nCommon failure reasons include:\n- Invalid CIDR notation\n- CIDR block conflicts with existing networks\n- NetworkClass does not support requested capabilities (e.g., dual-stack not supported)\n- NetworkClass is not in READY state\n- Network backend configuration error\n\nThe status.message field will contain specific error details. Failed networks typically require deletion\nand recreation with corrected parameters."
    },
    "v1VirtualNetworkStatus": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1VirtualNetworkState",
          "description": "Current lifecycle state of the virtual network."
        },
        "message": {
          "type": "string",
          "description": "Human-readable message providing additional details about the current state.\n\nFor PENDING state, this might contain progress information like \"Allocating IP address space\" or\n\"Configuring network backend\".\n\nFor FAILED state, this contains error details explaining what went wrong, such as \"Invalid CIDR range\" or\n\"NetworkClass does not support dual-stack\".\n\nFor READY state, this is typically empty or contains confirmation like \"Network ready for compute instances\"."
        }
      },
      "description": "Represents the current operational state of a VirtualNetwork.\n\nStatus is system-provided and read-only. Users cannot modify status fields directly; the system updates them\nbased on the reconciliation of the spec."
    },
    "v1VirtualNetworksCreateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1VirtualNetwork"
        }
      }
    },
    "v1VirtualNetworksDeleteResponse": {
      "type": "object"
    },
    "v1VirtualNetworksGetResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1VirtualNetwork"
        }
      }
    },
    "v1VirtualNetworksListResponse": {
      "type": "object",
      "properties": {
        "size": {
          "type": "integer",
          "format": "int32",
          "description": "Actual number of items returned. Note that this may be smaller than the value requested in the `limit` parameter\nof the request if there are not enough items, or if the system decides that returning that number of items isn't\nfeasible or convenient for performance reasons."
        },
        "total": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of items of the collection that match the search criteria, regardless of the number of results\nrequested with the `limit` parameter."
        },
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1VirtualNetwork"
          },
          "description": "List of results."
        }
      }
    },
    "v1VirtualNetworksUpdateResponse": {
      "type": "object",
      "properties": {
        "object": {
          "$ref": "#/definitions/v1VirtualNetwork"
        }
      }
    }
  }
}
